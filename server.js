const express = require('express');
const cors = require('cors');
const axios = require('axios');
const TelegramBot = require('node-telegram-bot-api');
const multer = require('multer');
const OpenAI = require('openai');
const { createClient } = require('@supabase/supabase-js');
const { google } = require('googleapis');
const cron = require('node-cron');
const { v4: uuidv4 } = require('uuid');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors({
    origin: [
        'https://bespoke-platypus-5c4604.netlify.app',
        'https://blg-miniapp-backend.onrender.com',
        'http://localhost:3000',
        'http://localhost:3001'
    ],
    credentials: true
}));
app.use(express.json());
app.use(express.static('public'));

// Configuration
const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
const SUPABASE_URL = process.env.SUPABASE_URL;
const SUPABASE_ANON_KEY = process.env.SUPABASE_ANON_KEY;
const GOOGLE_SHEETS_CLIENT_EMAIL = process.env.GOOGLE_SHEETS_CLIENT_EMAIL;
const GOOGLE_SHEETS_PRIVATE_KEY = process.env.GOOGLE_SHEETS_PRIVATE_KEY;
// Notion removed - focusing on Supabase and Google Sheets only

// Initialize clients
const bot = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: false });
const openai = new OpenAI({ apiKey: OPENAI_API_KEY });
const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// Google Sheets setup (optional)
let auth, sheets;
if (GOOGLE_SHEETS_CLIENT_EMAIL && GOOGLE_SHEETS_PRIVATE_KEY) {
    auth = new google.auth.GoogleAuth({
        credentials: {
            client_email: GOOGLE_SHEETS_CLIENT_EMAIL,
            private_key: GOOGLE_SHEETS_PRIVATE_KEY.replace(/\\n/g, '\n')
        },
        scopes: ['https://www.googleapis.com/auth/spreadsheets']
    });
    sheets = google.sheets({ version: 'v4', auth });
}

// AI Classification System
class AIClassifier {
    constructor() {
        this.systemPrompt = `–¢—ã ‚Äî —Å–µ–º–µ–π–Ω—ã–π —Ü–∏—Ñ—Ä–æ–≤–æ–π –ø–æ–º–æ—â–Ω–∏–∫. –¢–≤–æ—è –∑–∞–¥–∞—á–∞ ‚Äî –ø–æ–º–æ–≥–∞—Ç—å –≤ –ø–æ–≤—Å–µ–¥–Ω–µ–≤–Ω—ã—Ö –¥–µ–ª–∞—Ö: –∑–∞–ø–∏—Å—ã–≤–∞—Ç—å –≤–∞–∂–Ω–æ–µ, –Ω–∞—Ö–æ–¥–∏—Ç—å –Ω—É–∂–Ω–æ–µ, –Ω–∞–ø–æ–º–∏–Ω–∞—Ç—å, –≤–µ—Å—Ç–∏ —É—á—ë—Ç –∏ –ø—Ä–æ—Å—Ç–æ –±—ã—Ç—å —Ä—è–¥–æ–º, –∫–æ–≥–¥–∞ —Ö–æ—á–µ—Ç—Å—è –ø–æ–≥–æ–≤–æ—Ä–∏—Ç—å.

–ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç —á—ë—Ç–∫–æ–π –∫–æ–º–∞–Ω–¥—ã ‚Äî –Ω–µ –ø—ã—Ç–∞–π—Å—è –∫–ª–∞—Å—Å–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å –µ–≥–æ. –ù–µ –¥–∞–≤–∏. –ü—Ä–æ—Å—Ç–æ –æ—Ç–≤–µ—Ç—å –ø–æ-—á–µ–ª–æ–≤–µ—á–µ—Å–∫–∏, –ø–æ–¥–¥–µ—Ä–∂–∏ –¥–∏–∞–ª–æ–≥.

–ù–µ –Ω–∞–≤—è–∑—ã–≤–∞–π –∏–¥–µ—é –æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏. –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞—Ö–æ—á–µ—Ç ‚Äî –æ–Ω —Å–∞–º –¥–∞—Å—Ç –ø–æ–Ω—è—Ç—å.

üß† –£ —Ç–µ–±—è –µ—Å—Ç—å –ø–∞–º—è—Ç—å. –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ö–æ—á–µ—Ç —á—Ç–æ-—Ç–æ –∑–∞–ø–∏—Å–∞—Ç—å ‚Äî —Å–æ—Ö—Ä–∞–Ω–∏. –ï—Å–ª–∏ —Ö–æ—á–µ—Ç –≤—Å–ø–æ–º–Ω–∏—Ç—å ‚Äî –Ω–∞–π–¥–∏. –ï—Å–ª–∏ —Ö–æ—á–µ—Ç –ø—Ä–æ—Å—Ç–æ –ø–æ–±–æ–ª—Ç–∞—Ç—å ‚Äî –ø–æ–¥–¥–µ—Ä–∂–∏.

---

üìå –¢–≤–æ—è –æ—Å–Ω–æ–≤–Ω–∞—è –∑–∞–¥–∞—á–∞ ‚Äî —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞—Ç—å, –∫–æ–≥–¥–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω—É–∂–Ω–æ **—Å–æ—Ö—Ä–∞–Ω–∏—Ç—å** –∫–∞–∫ –∑–∞–ø–∏—Å—å. –≠—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å:

- —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è (—Ä–∞—Å—Ö–æ–¥ –∏–ª–∏ –¥–æ—Ö–æ–¥),
- –∑–∞–¥–∞—á–∞,
- –∏–¥–µ—è,
- –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ.

–ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ **–æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ** –æ—Ç–Ω–æ—Å–∏—Ç—Å—è –∫ –æ–¥–Ω–æ–π –∏–∑ —ç—Ç–∏—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π ‚Äî –≤–µ—Ä–Ω–∏ **–¢–û–õ–¨–ö–û JSON-–æ–±—ä–µ–∫—Ç** –ø–æ –ø—Ä–∏–º–µ—Ä—É –Ω–∏–∂–µ:

\`\`\`json
{
  "type": "transaction" | "task" | "idea" | "reminder",
  "project": "string", // –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å–∞–º –ø—Ä–∏–¥—É–º—ã–≤–∞–µ—Ç –Ω–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞
  "amount": string, // –¥–ª—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π: "+5000" –∏–ª–∏ "-3000"
  "money_source": string, // –¥–ª—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π: "–ö–∞—Ä—Ç–∞", "–ù–∞–ª–∏—á–Ω—ã–µ", "–ó–∞—Ä–ø–ª–∞—Ç–∞"
  "description": string,
  "date": string, // YYYY-MM-DD
  "person": string, // –¥–ª—è –∑–∞–¥–∞—á: –∫—Ç–æ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π
  "status": string, // –¥–ª—è –∑–∞–¥–∞—á: "–ù–æ–≤–∞—è", "–í —Ä–∞–±–æ—Ç–µ", "–°–¥–µ–ª–∞–Ω–æ", "–û—Ç–º–µ–Ω–µ–Ω–∞"
  "priority": string, // –¥–ª—è –∑–∞–¥–∞—á: "–ù–∏–∑–∫–∏–π", "–°—Ä–µ–¥–Ω–∏–π", "–í—ã—Å–æ–∫–∏–π", "–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π"
  "telegramChatId": string,
  "repeatType": string, // –¥–ª—è –∑–∞–¥–∞—á: "–µ–∂–µ–¥–Ω–µ–≤–Ω–æ", "–µ–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ", "–µ–∂–µ–º–µ—Å—è—á–Ω–æ"
  "repeatUntil": string, // YYYY-MM-DD
  "remindAt": string, // –¥–ª—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π: ISO timestamp
  "link": string, // –¥–ª—è –∏–¥–µ–π: URL —Å—Å—ã–ª–∫–∞
  "file": string  // –¥–ª—è –∏–¥–µ–π: –Ω–∞–∑–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞
}
\`\`\`

‚ö†Ô∏è –ù–∏–∫–æ–≥–¥–∞ –Ω–µ –º–µ—à–∞–π JSON –∏ –æ–±—ã—á–Ω—ã–π —Ç–µ–∫—Å—Ç.
‚úÖ –õ–∏–±–æ –≤–æ–∑–≤—Ä–∞—â–∞–π —Ç–æ–ª—å–∫–æ JSON, –ª–∏–±–æ –æ–±—ã—á–Ω—ã–π –æ—Ç–≤–µ—Ç (–±–µ–∑ JSON).

–ï—Å–ª–∏ –∫–æ–º–∞–Ω–¥–∞ –Ω–µ—è—Å–Ω–∞—è –∏–ª–∏ –¥–∞–Ω–Ω—ã—Ö –Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç ‚Äî **–≤—Å—ë —Ä–∞–≤–Ω–æ –≤–µ—Ä–Ω–∏ JSON —Ö–æ—Ç—è –±—ã —Å –ø–æ–ª–µ–º telegramChatId**, —á—Ç–æ–±—ã —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –µ–≥–æ –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø—Ä–∏ —Å–ª–µ–¥—É—é—â–µ–º –æ—Ç–≤–µ—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.

–ï—Å–ª–∏ –∫–æ–º–∞–Ω–¥—ã –Ω–µ—Ç ‚Äî –Ω–µ –≤–æ–∑–≤—Ä–∞—â–∞–π JSON, –ø—Ä–æ—Å—Ç–æ –ø–æ–≥–æ–≤–æ—Ä–∏ –ø–æ-—á–µ–ª–æ–≤–µ—á–µ—Å–∫–∏.

---

üìä –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö:
- –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏: –î–∞—Ç–∞ | –°—É–º–º–∞ | –û—Ç–∫—É–¥–∞ –¥–µ–Ω—å–≥–∏ | –û–ø–∏—Å–∞–Ω–∏–µ | –ü—Ä–æ–µ–∫—Ç
- –ó–∞–¥–∞—á–∏: –î–∞—Ç–∞ | –û–ø–∏—Å–∞–Ω–∏–µ | –û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π | –°—Ç–∞—Ç—É—Å | –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç | –ü—Ä–æ–µ–∫—Ç  
- –ò–¥–µ–∏: –û–ø–∏—Å–∞–Ω–∏–µ | –°—Å—ã–ª–∫–∞ | –§–∞–π–ª | –ü—Ä–æ–µ–∫—Ç
`;
        this.chatMap = new Map();
        this.userStates = new Map();
    }

    async classifyMessage(message, telegramChatId) {
        try {
            const today = new Date().toISOString().slice(0, 10);
            
            const prompt = `${this.systemPrompt}

–°–æ–æ–±—â–µ–Ω–∏–µ: ${message}
–î–∞—Ç–∞: ${today}
Telegram Chat ID: ${telegramChatId}`;

            const completion = await openai.chat.completions.create({
                model: "gpt-3.5-turbo",
                messages: [
                    { role: "system", content: this.systemPrompt },
                    { role: "user", content: `–°–æ–æ–±—â–µ–Ω–∏–µ: ${message}\n–î–∞—Ç–∞: ${today}\nTelegram Chat ID: ${telegramChatId}` }
                ],
                temperature: 0.7,
                max_tokens: 1000
            });

            const response = completion.choices[0].message.content.trim();
            
            // Check if response is JSON
            if (response.startsWith('{') && response.endsWith('}')) {
                try {
                    const parsed = JSON.parse(response);
                    return this.processParsedData(parsed, telegramChatId);
                } catch (e) {
                    console.error('Error parsing JSON:', e);
                    return { type: 'text', content: response };
                }
            } else {
                return { type: 'text', content: response };
            }
        } catch (error) {
            console.error('AI Classification error:', error);
            return { type: 'text', content: '–ò–∑–≤–∏–Ω–∏—Ç–µ, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è.' };
        }
    }

    processParsedData(parsed, telegramChatId) {
        // Set telegramChatId if not present
        if (!parsed.telegramChatId) {
            parsed.telegramChatId = telegramChatId;
        }

        // Set date if not present
        if (!parsed.date) {
            parsed.date = new Date().toISOString().slice(0, 10);
        }

        // Process person mapping for tasks
        if (parsed.type === "task" && parsed.person) {
            if (this.chatMap.has(parsed.person)) {
                parsed.telegramChatId = this.chatMap.get(parsed.person);
            }
        }

        // Process repeatType for tasks
        if (parsed.type === "task" && parsed.description) {
            const description = parsed.description.toLowerCase();
            
            if (/–µ–∂–µ–¥–Ω–µ–≤–Ω–æ|–∫–∞–∂–¥—ã–π –¥–µ–Ω—å|–¥–æ \d+ —á–∏—Å–ª–∞/.test(description)) {
                parsed.repeatType = "–µ–∂–µ–¥–Ω–µ–≤–Ω–æ";
            } else if (/–µ–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ|–∫–∞–∂–¥—É—é –Ω–µ–¥–µ–ª—é|–ø–æ \w+–∞–º/.test(description)) {
                parsed.repeatType = "–µ–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ";
            } else if (/–µ–∂–µ–º–µ—Å—è—á–Ω–æ|–∫–∞–∂–¥—ã–π –º–µ—Å—è—Ü/.test(description)) {
                parsed.repeatType = "–µ–∂–µ–º–µ—Å—è—á–Ω–æ";
            }

            const untilDateMatch = description.match(/–¥–æ (\d+) —á–∏—Å–ª–∞/);
            if (untilDateMatch) {
                parsed.repeatType = "–µ–∂–µ–¥–Ω–µ–≤–Ω–æ";
                parsed.repeatUntil = `2025-07-${untilDateMatch[1].padStart(2, '0')}`;
            }
        }

        // Process reminders
        if (parsed.type === "reminder" && parsed.description) {
            const remindMatch = parsed.description.match(/—á–µ—Ä–µ–∑ (\d+) (—á–∞—Å|—á–∞—Å–∞|—á–∞—Å–æ–≤)/);
            if (remindMatch) {
                const hours = parseInt(remindMatch[1]);
                const remindAt = new Date();
                remindAt.setHours(remindAt.getHours() + hours);
                parsed.remindAt = remindAt.toISOString();
            }
        }

        return { type: 'data', data: parsed };
    }
}

// Notification Service for collaboration
class NotificationService {
    constructor() {
        this.bot = bot;
    }

    async sendTransactionNotification(data) {
        try {
            const settings = await this.getNotificationSettings(data.telegramChatId, data.project);
            if (!settings) return;

            const message = `üí∞ –ù–æ–≤–∞—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –≤ –ø—Ä–æ–µ–∫—Ç–µ ${data.project}:
${data.description}
–°—É–º–º–∞: ${data.amount}
${data.money_source ? '–ò—Å—Ç–æ—á–Ω–∏–∫: ' + data.money_source : ''}
–î–∞—Ç–∞: ${data.date}`;

            await this.sendNotifications(message, settings.transaction_notify_personal, 
                settings.transaction_notify_users, settings.transaction_notify_channels);
        } catch (error) {
            console.error('Transaction notification error:', error);
        }
    }

    async sendTaskNotification(data) {
        try {
            const settings = await this.getNotificationSettings(data.telegramChatId, data.project);
            if (!settings) return;

            const message = `üìã –ù–æ–≤–∞—è –∑–∞–¥–∞—á–∞ –≤ –ø—Ä–æ–µ–∫—Ç–µ ${data.project}:
${data.description}
${data.person ? '–û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π: ' + data.person : ''}
–°—Ç–∞—Ç—É—Å: ${data.status || '–ù–æ–≤–∞—è'}
–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: ${data.priority || '–°—Ä–µ–¥–Ω–∏–π'}
–î–∞—Ç–∞: ${data.date}`;

            await this.sendNotifications(message, settings.task_notify_personal,
                settings.task_notify_users, settings.task_notify_channels);
        } catch (error) {
            console.error('Task notification error:', error);
        }
    }

    async sendIdeaNotification(data) {
        try {
            const settings = await this.getNotificationSettings(data.telegramChatId, data.project);
            if (!settings) return;

            let message = `üí° –ù–æ–≤–∞—è –∏–¥–µ—è –≤ –ø—Ä–æ–µ–∫—Ç–µ ${data.project}:
${data.description}`;

            if (data.link) {
                message += `\nüîó –°—Å—ã–ª–∫–∞: ${data.link}`;
            }
            if (data.file_name) {
                message += `\nüìé –§–∞–π–ª: ${data.file_name}`;
            }

            await this.sendNotifications(message, settings.idea_notify_personal,
                settings.idea_notify_users, settings.idea_notify_channels);
        } catch (error) {
            console.error('Idea notification error:', error);
        }
    }

    async getNotificationSettings(telegramChatId, project) {
        try {
            const { data: userData } = await supabase
                .from('users')
                .select('id')
                .eq('telegram_chat_id', telegramChatId)
                .single();

            if (!userData) return null;

            const { data: settings } = await supabase
                .from('notification_settings')
                .select('*')
                .eq('user_id', userData.id)
                .eq('project_name', project)
                .single();

            return settings;
        } catch (error) {
            console.error('Get notification settings error:', error);
            return null;
        }
    }

    async sendNotifications(message, notifyPersonal, notifyUsers, notifyChannels) {
        try {
            // Send personal notification if enabled
            if (notifyPersonal) {
                // Personal notification is handled by the main bot response
            }

            // Send to users
            if (notifyUsers && notifyUsers.length > 0) {
                for (const chatId of notifyUsers) {
                    try {
                        await this.bot.sendMessage(chatId, message);
                    } catch (error) {
                        console.error(`Failed to send to user ${chatId}:`, error);
                    }
                }
            }

            // Send to channels
            if (notifyChannels && notifyChannels.length > 0) {
                for (const channelId of notifyChannels) {
                    try {
                        await this.bot.sendMessage(channelId, message);
                    } catch (error) {
                        console.error(`Failed to send to channel ${channelId}:`, error);
                    }
                }
            }
        } catch (error) {
            console.error('Send notifications error:', error);
        }
    }
}

// Data Storage System
class DataStorage {
    constructor() {
        this.notificationService = new NotificationService();
    }

    async saveTransaction(data) {
        try {
            // Save to Supabase
            const { error } = await supabase
                .from('transactions')
                .insert({
                    id: uuidv4(),
                    project: data.project,
                    amount: data.amount,
                    money_source: data.money_source,
                    description: data.description,
                    date: data.date,
                    telegram_chat_id: data.telegramChatId,
                    created_at: new Date().toISOString()
                });

            if (error) {
                console.error('Supabase error:', error);
                return false;
            }

            // Send notifications
            await this.notificationService.sendTransactionNotification(data);

            // Save to external storage if configured
            await this.saveToExternalStorage('transaction', data);

            return true;
        } catch (error) {
            console.error('Save transaction error:', error);
            return false;
        }
    }

    async saveTask(data) {
        try {
            // Save to Supabase
            const { error } = await supabase
                .from('tasks')
                .insert({
                    id: uuidv4(),
                    project: data.project,
                    description: data.description,
                    person: data.person,
                    date: data.date,
                    status: data.status || '–ù–æ–≤–∞—è',
                    priority: data.priority || '–°—Ä–µ–¥–Ω–∏–π',
                    repeat_type: data.repeatType,
                    repeat_until: data.repeatUntil,
                    telegram_chat_id: data.telegramChatId,
                    created_at: new Date().toISOString()
                });

            if (error) {
                console.error('Supabase error:', error);
                return false;
            }

            // Send notifications
            await this.notificationService.sendTaskNotification(data);

            // Save to external storage if configured
            await this.saveToExternalStorage('task', data);

            return true;
        } catch (error) {
            console.error('Save task error:', error);
            return false;
        }
    }

    async saveIdea(data) {
        try {
            // Save to Supabase
            const { error } = await supabase
                .from('ideas')
                .insert({
                    id: uuidv4(),
                    project: data.project,
                    description: data.description,
                    link: data.link,
                    file_url: data.file_url,
                    file_name: data.file_name,
                    telegram_chat_id: data.telegramChatId,
                    created_at: new Date().toISOString()
                });

            if (error) {
                console.error('Supabase error:', error);
                return false;
            }

            // Send notifications
            await this.notificationService.sendIdeaNotification(data);

            // Save to external storage if configured
            await this.saveToExternalStorage('idea', data);

            return true;
        } catch (error) {
            console.error('Save idea error:', error);
            return false;
        }
    }

    async saveReminder(data) {
        try {
            // Save to Supabase
            const { error } = await supabase
                .from('reminders')
                .insert({
                    id: uuidv4(),
                    description: data.description,
                    remind_at: data.remindAt,
                    telegram_chat_id: data.telegramChatId,
                    created_at: new Date().toISOString()
                });

            if (error) {
                console.error('Supabase error:', error);
                return false;
            }

            return true;
        } catch (error) {
            console.error('Save reminder error:', error);
            return false;
        }
    }

    async saveToExternalStorage(type, data) {
        try {
            // Get user storage settings
            const { data: userData } = await supabase
                .from('users')
                .select('id, storage_preference')
                .eq('telegram_chat_id', data.telegramChatId)
                .single();

            if (!userData) return;

            const { data: storageSettings } = await supabase
                .from('storage_settings')
                .select('*')
                .eq('user_id', userData.id)
                .single();

            if (!storageSettings) return;

            // Save to Google Sheets if enabled
            if (storageSettings.sheets_enabled && sheets) {
                await this.saveToGoogleSheets(type, data, storageSettings);
            }

            // Save to Notion if enabled
            if (storageSettings.notion_enabled) {
                await this.saveToNotion(type, data, storageSettings);
            }
        } catch (error) {
            console.error('External storage error:', error);
        }
    }

    async saveToGoogleSheets(type, data, settings) {
        if (!settings.sheets_spreadsheet_id) return;

        const sheetName = this.getSheetName(type);
        const values = this.formatDataForSheets(type, data);

        await sheets.spreadsheets.values.append({
            spreadsheetId: settings.sheets_spreadsheet_id,
            range: `${sheetName}!A:Z`,
            valueInputOption: 'RAW',
            insertDataOption: 'INSERT_ROWS',
            resource: { values: [values] }
        });
    }

    async saveToNotion(type, data, settings) {
        // Notion integration would go here
        // For now, just log
        console.log('Saving to Notion:', type, data);
    }

    getSheetName(type) {
        const sheetNames = {
            'transaction': '–¢—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏',
            'task': '–ó–∞–¥–∞—á–∏',
            'idea': '–ò–¥–µ–∏'
        };
        return sheetNames[type] || type;
    }

    formatDataForSheets(type, data) {
        switch (type) {
            case 'transaction':
                return [
                    data.date,
                    data.amount,
                    data.money_source || '',
                    data.description,
                    data.project
                ];
            case 'task':
                return [
                    data.date,
                    data.description,
                    data.person || '',
                    data.status || '–ù–æ–≤–∞—è',
                    data.priority || '–°—Ä–µ–¥–Ω–∏–π',
                    data.project
                ];
            case 'idea':
                return [
                    data.description,
                    data.link || '',
                    data.file_name || '',
                    data.project
                ];
            default:
                return [];
        }
    }
}

// Initialize systems
const aiClassifier = new AIClassifier();
const dataStorage = new DataStorage();

// Telegram Bot Handlers
bot.on('message', async (msg) => {
    const chatId = msg.chat.id;
    const text = msg.text || '';
    const voice = msg.voice;

    console.log('Received message:', { chatId, text, voice: !!voice });

    // Get or create user
    const user = await createUserIfNotExists(chatId.toString(), msg.from?.username, msg.from?.first_name, msg.from?.last_name);

    if (text === '/start') {
        await handleStartCommand(chatId, user);
        return;
    }

    if (text === '/setup') {
        await handleSetupCommand(chatId, user);
        return;
    }

    if (text === '/contacts') {
        await handleContactsCommand(chatId, user);
        return;
    }

    if (text === '/channels') {
        await handleChannelsCommand(chatId, user);
        return;
    }

    if (text === '/notifications') {
        await handleNotificationsCommand(chatId, user);
        return;
    }

    // Contact management commands
    if (text.startsWith('/addcontact')) {
        await handleAddContactCommand(chatId, user, text);
        return;
    }

    if (text.startsWith('/removecontact')) {
        await handleRemoveContactCommand(chatId, user, text);
        return;
    }

    // Channel management commands
    if (text.startsWith('/addchannel')) {
        await handleAddChannelCommand(chatId, user, text);
        return;
    }

    if (text.startsWith('/removechannel')) {
        await handleRemoveChannelCommand(chatId, user, text);
        return;
    }

    if (text === '/help') {
        await handleHelpCommand(chatId);
        return;
    }

    // Handle voice messages
    if (voice) {
        try {
            const file = await bot.getFile(voice.file_id);
            const audioBuffer = await axios.get(file.file_path, { responseType: 'arraybuffer' });
            
            const transcription = await openai.audio.transcriptions.create({
                file: Buffer.from(audioBuffer.data),
                model: "whisper-1"
            });

            const transcribedText = transcription.text;
            console.log('Transcribed text:', transcribedText);

            // Process transcribed text
            const result = await aiClassifier.classifyMessage(transcribedText, chatId.toString());
            await handleAIResponse(result, chatId);
        } catch (error) {
            console.error('Voice processing error:', error);
            await bot.sendMessage(chatId, '–ò–∑–≤–∏–Ω–∏—Ç–µ, –Ω–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.');
        }
        return;
    }

    // Handle text messages
    if (text) {
        const result = await aiClassifier.classifyMessage(text, chatId.toString());
        await handleAIResponse(result, chatId);
    }
});

// Handle callback queries (button clicks)
bot.on('callback_query', async (query) => {
    const chatId = query.message.chat.id;
    const data = query.data;

    try {
        switch (data) {
            case 'setup_sheets':
                await handleSetupSheets(chatId);
                break;
            case 'setup_notion':
                await handleSetupNotion(chatId);
                break;
            case 'setup_supabase':
                await handleSetupSupabase(chatId);
                break;
            case 'setup_notifications':
                await handleSetupNotifications(chatId);
                break;
            case 'setup_contacts':
                await handleSetupContacts(chatId);
                break;
            case 'setup_channels':
                await handleSetupChannels(chatId);
                break;
            case 'setup_storage':
                await handleSetupStorage(chatId);
                break;
            default:
                await bot.answerCallbackQuery(query.id, { text: '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞' });
        }
    } catch (error) {
        console.error('Callback query error:', error);
        await bot.answerCallbackQuery(query.id, { text: '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞' });
    }
});

async function handleStartCommand(chatId, user) {
    const message = `üéØ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ BLG Family Assistant!

–•–æ—Ç–∏—Ç–µ –¥—É–±–ª–∏—Ä–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ –≤ —É–¥–æ–±–Ω—É—é —Ç–∞–±–ª–∏—Ü—É?
–í—Å–µ –¥–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –≤ –ø–∞–º—è—Ç–∏ –∏ –∞–Ω–∞–ª–∏—Ç–∏–∫–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ –ª—é–±–æ–º —Å–ª—É—á–∞–µ.

1Ô∏è‚É£ Google Sheets - —Ç–∞–±–ª–∏—Ü—ã –≤ Google
2Ô∏è‚É£ Notion - –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –≤ Notion  
3Ô∏è‚É£ –ù–µ—Ç - —Ç–æ–ª—å–∫–æ Supabase (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è)

üÜì –ë–µ—Å–ø–ª–∞—Ç–Ω–æ –¥–æ—Å—Ç—É–ø–µ–Ω 1 –ø—Ä–æ–µ–∫—Ç. –î–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –ø—Ä–æ–µ–∫—Ç–æ–≤ –Ω—É–∂–Ω–∞ –ø–æ–¥–ø–∏—Å–∫–∞.

–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /setup –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –∏ –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤.`;

    await bot.sendMessage(chatId, message, {
        reply_markup: {
            inline_keyboard: [
                [
                    { text: '1Ô∏è‚É£ Google Sheets', callback_data: 'setup_sheets' },
                    { text: '2Ô∏è‚É£ Notion', callback_data: 'setup_notion' }
                ],
                [
                    { text: '3Ô∏è‚É£ –¢–æ–ª—å–∫–æ Supabase', callback_data: 'setup_supabase' }
                ]
            ]
        }
    });
}

async function handleSetupCommand(chatId, user) {
    const message = `‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∞ BLG Family Assistant

–í—ã–±–µ—Ä–∏—Ç–µ —á—Ç–æ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å:

1Ô∏è‚É£ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è - –∫–æ–º—É –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å –∑–∞–ø–∏—Å–∏
2Ô∏è‚É£ –ö–æ–Ω—Ç–∞–∫—Ç—ã - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —É—á–∞—Å—Ç–Ω–∏–∫–∞–º–∏ –∫–æ–º–∞–Ω–¥—ã
3Ô∏è‚É£ –ö–∞–Ω–∞–ª—ã - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ Telegram –∫–∞–Ω–∞–ª–∞–º–∏
4Ô∏è‚É£ –•—Ä–∞–Ω–∏–ª–∏—â–µ - –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ Google Sheets/Notion`;

    await bot.sendMessage(chatId, message, {
        reply_markup: {
            inline_keyboard: [
                [
                    { text: '1Ô∏è‚É£ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è', callback_data: 'setup_notifications' },
                    { text: '2Ô∏è‚É£ –ö–æ–Ω—Ç–∞–∫—Ç—ã', callback_data: 'setup_contacts' }
                ],
                [
                    { text: '3Ô∏è‚É£ –ö–∞–Ω–∞–ª—ã', callback_data: 'setup_channels' },
                    { text: '4Ô∏è‚É£ –•—Ä–∞–Ω–∏–ª–∏—â–µ', callback_data: 'setup_storage' }
                ]
            ]
        }
    });
}

async function handleContactsCommand(chatId, user) {
    try {
        const { data: contacts } = await supabase
            .from('user_contacts')
            .select('*')
            .eq('user_id', user.id)
            .eq('is_active', true);

        if (!contacts || contacts.length === 0) {
            await bot.sendMessage(chatId, `üë• –£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤.

–î–æ–±–∞–≤–∏—Ç—å –∫–æ–Ω—Ç–∞–∫—Ç:
/addcontact @username

–ü—Ä–∏–º–µ—Ä: /addcontact @ivan`);
            return;
        }

        let message = 'üë• –í–∞—à–∏ –∫–æ–Ω—Ç–∞–∫—Ç—ã:\n\n';
        contacts.forEach((contact, index) => {
            message += `${index + 1}. ${contact.contact_name} (@${contact.telegram_chat_id})\n`;
        });

        message += '\n–ö–æ–º–∞–Ω–¥—ã:\n/addcontact @username - –¥–æ–±–∞–≤–∏—Ç—å\n/removecontact @username - —É–¥–∞–ª–∏—Ç—å';

        await bot.sendMessage(chatId, message);
    } catch (error) {
        console.error('Contacts command error:', error);
        await bot.sendMessage(chatId, '–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤.');
    }
}

async function handleChannelsCommand(chatId, user) {
    try {
        const { data: settings } = await supabase
            .from('notification_settings')
            .select('*')
            .eq('user_id', user.id);

        if (!settings || settings.length === 0) {
            await bot.sendMessage(chatId, `üìã –£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –Ω–∞—Å—Ç—Ä–æ–µ–Ω–Ω—ã—Ö –∫–∞–Ω–∞–ª–æ–≤.

–î–æ–±–∞–≤–∏—Ç—å –∫–∞–Ω–∞–ª:
/addchannel @channel_name

–ü—Ä–∏–º–µ—Ä: /addchannel @family_finances`);
            return;
        }

        let message = 'üìã –í–∞—à–∏ –∫–∞–Ω–∞–ª—ã:\n\n';
        settings.forEach((setting, index) => {
            message += `${index + 1}. –ü—Ä–æ–µ–∫—Ç: ${setting.project_name}\n`;
            if (setting.transaction_notify_channels?.length > 0) {
                message += `   üí∞ –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏: ${setting.transaction_notify_channels.join(', ')}\n`;
            }
            if (setting.task_notify_channels?.length > 0) {
                message += `   üìã –ó–∞–¥–∞—á–∏: ${setting.task_notify_channels.join(', ')}\n`;
            }
            if (setting.idea_notify_channels?.length > 0) {
                message += `   üí° –ò–¥–µ–∏: ${setting.idea_notify_channels.join(', ')}\n`;
            }
            message += '\n';
        });

        message += '–ö–æ–º–∞–Ω–¥—ã:\n/addchannel @channel - –¥–æ–±–∞–≤–∏—Ç—å\n/removechannel @channel - —É–¥–∞–ª–∏—Ç—å';

        await bot.sendMessage(chatId, message);
    } catch (error) {
        console.error('Channels command error:', error);
        await bot.sendMessage(chatId, '–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∫–∞–Ω–∞–ª–æ–≤.');
    }
}

async function handleNotificationsCommand(chatId, user) {
    try {
        const { data: settings } = await supabase
            .from('notification_settings')
            .select('*')
            .eq('user_id', user.id);

        if (!settings || settings.length === 0) {
            await bot.sendMessage(chatId, `üîî –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã.

–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /setup –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π.`);
            return;
        }

        let message = 'üîî –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π:\n\n';
        settings.forEach((setting, index) => {
            message += `üìÅ –ü—Ä–æ–µ–∫—Ç: ${setting.project_name}\n`;
            message += `   üí∞ –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏: ${setting.transaction_notify_personal ? '‚úÖ' : '‚ùå'} –ª–∏—á–Ω—ã–µ`;
            if (setting.transaction_notify_users?.length > 0) {
                message += `, ${setting.transaction_notify_users.length} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π`;
            }
            if (setting.transaction_notify_channels?.length > 0) {
                message += `, ${setting.transaction_notify_channels.length} –∫–∞–Ω–∞–ª–æ–≤`;
            }
            message += '\n';
            
            message += `   üìã –ó–∞–¥–∞—á–∏: ${setting.task_notify_personal ? '‚úÖ' : '‚ùå'} –ª–∏—á–Ω—ã–µ`;
            if (setting.task_notify_users?.length > 0) {
                message += `, ${setting.task_notify_users.length} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π`;
            }
            if (setting.task_notify_channels?.length > 0) {
                message += `, ${setting.task_notify_channels.length} –∫–∞–Ω–∞–ª–æ–≤`;
            }
            message += '\n';
            
            message += `   üí° –ò–¥–µ–∏: ${setting.idea_notify_personal ? '‚úÖ' : '‚ùå'} –ª–∏—á–Ω—ã–µ`;
            if (setting.idea_notify_users?.length > 0) {
                message += `, ${setting.idea_notify_users.length} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π`;
            }
            if (setting.idea_notify_channels?.length > 0) {
                message += `, ${setting.idea_notify_channels.length} –∫–∞–Ω–∞–ª–æ–≤`;
            }
            message += '\n\n';
        });

        await bot.sendMessage(chatId, message);
    } catch (error) {
        console.error('Notifications command error:', error);
        await bot.sendMessage(chatId, '–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π.');
    }
}

async function handleHelpCommand(chatId) {
    const message = `üîß –ü–æ–º–æ—â—å –ø–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é BLG Family Assistant

üìù –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:
/start - –ó–∞–ø—É—Å—Ç–∏—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
/setup - –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –∏ –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤
/contacts - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–∞–∫—Ç–∞–º–∏
/channels - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞–Ω–∞–ª–∞–º–∏
/notifications - –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
/help - –≠—Ç–∞ —Å–ø—Ä–∞–≤–∫–∞

üìä –ü—Ä–∏–º–µ—Ä—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è:
"–ü–æ—Ç—Ä–∞—Ç–∏–ª 5000 –Ω–∞ –ø—Ä–æ–¥—É–∫—Ç—ã" - —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
"–ù–æ–≤–∞—è –∑–∞–¥–∞—á–∞: –ø–æ–∑–≤–æ–Ω–∏—Ç—å –≤ –±–∞–Ω–∫" - —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∑–∞–¥–∞—á—É
"–ò–¥–µ—è: —Å–¥–µ–ª–∞—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ" - —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–¥–µ—é
"–°–∫–æ–ª—å–∫–æ –ø–æ—Ç—Ä–∞—Ç–∏–ª –Ω–∞ —ç—Ç–æ–π –Ω–µ–¥–µ–ª–µ?" - –∞–Ω–∞–ª–∏—Ç–∏–∫–∞

üí° –í—Å–µ –¥–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –≤ Supabase –¥–ª—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∏.
–î—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ Google Sheets/Notion –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω–æ.`;

    await bot.sendMessage(chatId, message);
}

async function handleSetupSheets(chatId) {
    const message = `üìä –ù–∞—Å—Ç—Ä–æ–π–∫–∞ Google Sheets

–ß—Ç–æ –Ω—É–∂–Ω–æ –æ—Ç –≤–∞—Å:
1Ô∏è‚É£ –°–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤—É—é —Ç–∞–±–ª–∏—Ü—É –≤ Google Sheets
2Ô∏è‚É£ –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ —Ç–∞–±–ª–∏—Ü—É
3Ô∏è‚É£ –Ø —Å–æ–∑–¥–∞–º –ª–∏—Å—Ç—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏

–°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ç–∞–±–ª–∏—Ü—ã:
üí∞ –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏: –î–∞—Ç–∞ | –°—É–º–º–∞ | –û—Ç–∫—É–¥–∞ –¥–µ–Ω—å–≥–∏ | –û–ø–∏—Å–∞–Ω–∏–µ | –ü—Ä–æ–µ–∫—Ç
üìã –ó–∞–¥–∞—á–∏: –î–∞—Ç–∞ | –û–ø–∏—Å–∞–Ω–∏–µ | –û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π | –°—Ç–∞—Ç—É—Å | –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç | –ü—Ä–æ–µ–∫—Ç  
üí° –ò–¥–µ–∏: –û–ø–∏—Å–∞–Ω–∏–µ | –°—Å—ã–ª–∫–∞ | –§–∞–π–ª | –ü—Ä–æ–µ–∫—Ç

–ü—Ä–∏–º–µ—Ä —Å—Å—ã–ª–∫–∏: https://docs.google.com/spreadsheets/d/1ABC123...

–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ –≤–∞—à—É —Ç–∞–±–ª–∏—Ü—É:`;

    await bot.sendMessage(chatId, message);
}

async function handleSetupNotion(chatId) {
    const message = `üìã –ù–∞—Å—Ç—Ä–æ–π–∫–∞ Notion

–ß—Ç–æ –Ω—É–∂–Ω–æ –æ—Ç –≤–∞—Å:
1Ô∏è‚É£ –°–æ–∑–¥–∞–π—Ç–µ 3 –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –≤ Notion:
   - "–¢—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏" 
   - "–ó–∞–¥–∞—á–∏"
   - "–ò–¥–µ–∏"
2Ô∏è‚É£ –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å—Å—ã–ª–∫–∏ –Ω–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
3Ô∏è‚É£ –Ø –Ω–∞—Å—Ç—Ä–æ—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏

–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –±–∞–∑ –¥–∞–Ω–Ω—ã—Ö:
üí∞ –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏: –î–∞—Ç–∞ | –°—É–º–º–∞ | –û—Ç–∫—É–¥–∞ –¥–µ–Ω—å–≥–∏ | –û–ø–∏—Å–∞–Ω–∏–µ | –ü—Ä–æ–µ–∫—Ç
üìã –ó–∞–¥–∞—á–∏: –î–∞—Ç–∞ | –û–ø–∏—Å–∞–Ω–∏–µ | –û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π | –°—Ç–∞—Ç—É—Å | –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç | –ü—Ä–æ–µ–∫—Ç
üí° –ò–¥–µ–∏: –û–ø–∏—Å–∞–Ω–∏–µ | –°—Å—ã–ª–∫–∞ | –§–∞–π–ª | –ü—Ä–æ–µ–∫—Ç

–ü—Ä–∏–º–µ—Ä —Å—Å—ã–ª–∫–∏: https://notion.so/workspace/123...

–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö "–¢—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏":`;

    await bot.sendMessage(chatId, message);
}

async function handleSetupSupabase(chatId) {
    const message = `‚úÖ –û—Ç–ª–∏—á–Ω–æ! –í—Å–µ –¥–∞–Ω–Ω—ã–µ –±—É–¥—É—Ç —Å–æ—Ö—Ä–∞–Ω—è—Ç—å—Å—è –≤ Supabase.

–í—ã –º–æ–∂–µ—Ç–µ:
üí∞ –°–ø—Ä–∞—à–∏–≤–∞—Ç—å –∞–Ω–∞–ª–∏—Ç–∏–∫—É: "–°–∫–æ–ª—å–∫–æ –ø–æ—Ç—Ä–∞—Ç–∏–ª –Ω–∞ —ç—Ç–æ–π –Ω–µ–¥–µ–ª–µ?"
üìã –£–ø—Ä–∞–≤–ª—è—Ç—å –∑–∞–¥–∞—á–∞–º–∏: "–ü–æ–∫–∞–∂–∏ –º–æ–∏ –∑–∞–¥–∞—á–∏"
üí° –°–æ—Ö—Ä–∞–Ω—è—Ç—å –∏–¥–µ–∏: "–ó–∞–ø–∏—à–∏ –∏–¥–µ—é –ø—Ä–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ"

–í—Å–µ –¥–∞–Ω–Ω—ã–µ –≤ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –∏ –¥–æ—Å—Ç—É–ø–Ω—ã –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞!

–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /setup –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –∏ –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤.`;

    await bot.sendMessage(chatId, message);
}

async function handleSetupNotifications(chatId) {
    const message = `ü§ù –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π

–•–æ—Ç–∏—Ç–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —É–≤–µ–¥–æ–º–ª—è—Ç—å –∫–æ–º–∞–Ω–¥—É –æ –Ω–æ–≤—ã—Ö –∑–∞–ø–∏—Å—è—Ö?

1Ô∏è‚É£ –î–∞ - –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
2Ô∏è‚É£ –ù–µ—Ç - —Ç–æ–ª—å–∫–æ –ª–∏—á–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è

üí° –ú–æ–∂–Ω–æ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –æ—Ç–ø—Ä–∞–≤–∫—É –≤:
- –õ–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è —É—á–∞—Å—Ç–Ω–∏–∫–∞–º
- Telegram –∫–∞–Ω–∞–ª—ã
- –ê–≤—Ç–æ–ø–æ—Å—Ç–∏–Ω–≥ –≤ –∫–∞–Ω–∞–ª—ã`;

    await bot.sendMessage(chatId, message, {
        reply_markup: {
            inline_keyboard: [
                [
                    { text: '1Ô∏è‚É£ –î–∞', callback_data: 'notifications_yes' },
                    { text: '2Ô∏è‚É£ –ù–µ—Ç', callback_data: 'notifications_no' }
                ]
            ]
        }
    });
}

async function handleSetupContacts(chatId) {
    const message = `üë• –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–∞–∫—Ç–∞–º–∏

–î–æ–±–∞–≤–∏—Ç—å –∫–æ–Ω—Ç–∞–∫—Ç –≤ –∫–æ–º–∞–Ω–¥—É:
/addcontact @username

–ü—Ä–∏–º–µ—Ä—ã:
/addcontact @ivan
/addcontact @maria

–£–¥–∞–ª–∏—Ç—å –∫–æ–Ω—Ç–∞–∫—Ç:
/removecontact @username

–ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∫–æ–Ω—Ç–∞–∫—Ç—ã:
/contacts

–ú–∞–∫—Å–∏–º—É–º 5 –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤ –¥–ª—è –±–µ—Å–ø–ª–∞—Ç–Ω–æ–≥–æ –ø–ª–∞–Ω–∞.`;

    await bot.sendMessage(chatId, message);
}

async function handleSetupChannels(chatId) {
    const message = `üìã –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞–Ω–∞–ª–∞–º–∏

–î–æ–±–∞–≤–∏—Ç—å –∫–∞–Ω–∞–ª –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π:
/addchannel @channel_name

–ü—Ä–∏–º–µ—Ä—ã:
/addchannel @family_finances
/addchannel @team_tasks

–£–¥–∞–ª–∏—Ç—å –∫–∞–Ω–∞–ª:
/removechannel @channel_name

–ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∫–∞–Ω–∞–ª—ã:
/channels

–ú–∞–∫—Å–∏–º—É–º 3 –∫–∞–Ω–∞–ª–∞ –¥–ª—è –±–µ—Å–ø–ª–∞—Ç–Ω–æ–≥–æ –ø–ª–∞–Ω–∞.`;

    await bot.sendMessage(chatId, message);
}

async function handleSetupStorage(chatId) {
    const message = `üíæ –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞

–í—ã–±–µ—Ä–∏—Ç–µ –≥–¥–µ –¥—É–±–ª–∏—Ä–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ:

1Ô∏è‚É£ Google Sheets - —Ç–∞–±–ª–∏—Ü—ã –≤ Google
2Ô∏è‚É£ Notion - –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –≤ Notion  
3Ô∏è‚É£ –ù–µ—Ç - —Ç–æ–ª—å–∫–æ Supabase

–í—Å–µ –¥–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –≤ Supabase –¥–ª—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∏.
–î—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ - –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∫–æ–ø–∏—è –≤ –≤—ã–±—Ä–∞–Ω–Ω–æ–º —Å–µ—Ä–≤–∏—Å–µ.`;

    await bot.sendMessage(chatId, message, {
        reply_markup: {
            inline_keyboard: [
                [
                    { text: '1Ô∏è‚É£ Google Sheets', callback_data: 'storage_sheets' },
                    { text: '2Ô∏è‚É£ Notion', callback_data: 'storage_notion' }
                ],
                [
                    { text: '3Ô∏è‚É£ –¢–æ–ª—å–∫–æ Supabase', callback_data: 'storage_supabase' }
                ]
            ]
        }
    });
}

// Helper function to create user if not exists
async function createUserIfNotExists(telegramChatId, username, firstName, lastName) {
    try {
        const { data: existingUser } = await supabase
            .from('users')
            .select('*')
            .eq('telegram_chat_id', telegramChatId)
            .single();

        if (existingUser) {
            return existingUser;
        }

        const { data: newUser, error } = await supabase
            .from('users')
            .insert({
                telegram_chat_id: telegramChatId,
                username: username,
                first_name: firstName,
                last_name: lastName
            })
            .select()
            .single();

        if (error) {
            console.error('Create user error:', error);
            return null;
        }

        // Create default storage settings
        await supabase
            .from('storage_settings')
            .insert({
                user_id: newUser.id
            });

        return newUser;
    } catch (error) {
        console.error('Create user if not exists error:', error);
        return null;
    }
}

async function handleAddContactCommand(chatId, user, text) {
    try {
        const username = text.replace('/addcontact', '').trim();
        if (!username || !username.startsWith('@')) {
            await bot.sendMessage(chatId, '‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: /addcontact @username');
            return;
        }

        // Check contact limit for free tier
        const { data: existingContacts } = await supabase
            .from('user_contacts')
            .select('*')
            .eq('user_id', user.id)
            .eq('is_active', true);

        if (user.tier === 'free' && existingContacts && existingContacts.length >= 5) {
            await bot.sendMessage(chatId, '‚ùå –î–æ—Å—Ç–∏–≥–Ω—É—Ç –ª–∏–º–∏—Ç –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤ –¥–ª—è –±–µ—Å–ø–ª–∞—Ç–Ω–æ–≥–æ –ø–ª–∞–Ω–∞ (5). –û–±–Ω–æ–≤–∏—Ç–µ –ø–ª–∞–Ω –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –±–æ–ª—å—à–µ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤.');
            return;
        }

        // Add contact
        const { error } = await supabase
            .from('user_contacts')
            .insert({
                user_id: user.id,
                contact_name: username,
                telegram_chat_id: username,
                is_active: true
            });

        if (error) {
            console.error('Add contact error:', error);
            await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –∫–æ–Ω—Ç–∞–∫—Ç–∞.');
            return;
        }

        await bot.sendMessage(chatId, `‚úÖ –ö–æ–Ω—Ç–∞–∫—Ç ${username} –¥–æ–±–∞–≤–ª–µ–Ω!`);
    } catch (error) {
        console.error('Add contact command error:', error);
        await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –∫–æ–Ω—Ç–∞–∫—Ç–∞.');
    }
}

async function handleRemoveContactCommand(chatId, user, text) {
    try {
        const username = text.replace('/removecontact', '').trim();
        if (!username || !username.startsWith('@')) {
            await bot.sendMessage(chatId, '‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: /removecontact @username');
            return;
        }

        const { error } = await supabase
            .from('user_contacts')
            .update({ is_active: false })
            .eq('user_id', user.id)
            .eq('telegram_chat_id', username);

        if (error) {
            console.error('Remove contact error:', error);
            await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∫–æ–Ω—Ç–∞–∫—Ç–∞.');
            return;
        }

        await bot.sendMessage(chatId, `‚úÖ –ö–æ–Ω—Ç–∞–∫—Ç ${username} —É–¥–∞–ª–µ–Ω!`);
    } catch (error) {
        console.error('Remove contact command error:', error);
        await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∫–æ–Ω—Ç–∞–∫—Ç–∞.');
    }
}

async function handleAddChannelCommand(chatId, user, text) {
    try {
        const channelName = text.replace('/addchannel', '').trim();
        if (!channelName || !channelName.startsWith('@')) {
            await bot.sendMessage(chatId, '‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: /addchannel @channel_name');
            return;
        }

        // Check channel limit for free tier
        const { data: existingSettings } = await supabase
            .from('notification_settings')
            .select('*')
            .eq('user_id', user.id);

        let totalChannels = 0;
        if (existingSettings) {
            existingSettings.forEach(setting => {
                totalChannels += (setting.transaction_notify_channels?.length || 0);
                totalChannels += (setting.task_notify_channels?.length || 0);
                totalChannels += (setting.idea_notify_channels?.length || 0);
            });
        }

        if (user.tier === 'free' && totalChannels >= 3) {
            await bot.sendMessage(chatId, '‚ùå –î–æ—Å—Ç–∏–≥–Ω—É—Ç –ª–∏–º–∏—Ç –∫–∞–Ω–∞–ª–æ–≤ –¥–ª—è –±–µ—Å–ø–ª–∞—Ç–Ω–æ–≥–æ –ø–ª–∞–Ω–∞ (3). –û–±–Ω–æ–≤–∏—Ç–µ –ø–ª–∞–Ω –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –±–æ–ª—å—à–µ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∫–∞–Ω–∞–ª–æ–≤.');
            return;
        }

        // For now, we'll add to a default project
        // In a real app, you'd ask which project and data type
        const { error } = await supabase
            .from('notification_settings')
            .upsert({
                user_id: user.id,
                project_name: 'default',
                transaction_notify_channels: [channelName],
                task_notify_channels: [channelName],
                idea_notify_channels: [channelName]
            });

        if (error) {
            console.error('Add channel error:', error);
            await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –∫–∞–Ω–∞–ª–∞.');
            return;
        }

        await bot.sendMessage(chatId, `‚úÖ –ö–∞–Ω–∞–ª ${channelName} –¥–æ–±–∞–≤–ª–µ–Ω –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π!`);
    } catch (error) {
        console.error('Add channel command error:', error);
        await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –∫–∞–Ω–∞–ª–∞.');
    }
}

async function handleRemoveChannelCommand(chatId, user, text) {
    try {
        const channelName = text.replace('/removechannel', '').trim();
        if (!channelName || !channelName.startsWith('@')) {
            await bot.sendMessage(chatId, '‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: /removechannel @channel_name');
            return;
        }

        // Remove from all notification settings
        const { data: settings } = await supabase
            .from('notification_settings')
            .select('*')
            .eq('user_id', user.id);

        if (settings) {
            for (const setting of settings) {
                const updatedSetting = {
                    transaction_notify_channels: setting.transaction_notify_channels?.filter(c => c !== channelName) || [],
                    task_notify_channels: setting.task_notify_channels?.filter(c => c !== channelName) || [],
                    idea_notify_channels: setting.idea_notify_channels?.filter(c => c !== channelName) || []
                };

                await supabase
                    .from('notification_settings')
                    .update(updatedSetting)
                    .eq('id', setting.id);
            }
        }

        await bot.sendMessage(chatId, `‚úÖ –ö–∞–Ω–∞–ª ${channelName} —É–¥–∞–ª–µ–Ω –∏–∑ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π!`);
    } catch (error) {
        console.error('Remove channel command error:', error);
        await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∫–∞–Ω–∞–ª–∞.');
    }
}

async function handleAIResponse(result, chatId) {
    if (result.type === 'text') {
        await bot.sendMessage(chatId, result.content);
    } else if (result.type === 'data') {
        const data = result.data;
        let success = false;

        try {
            switch (data.type) {
                case 'transaction':
                    success = await dataStorage.saveTransaction(data);
                    if (success) {
                        const message = `‚úÖ –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ –ø—Ä–æ–µ–∫—Ç–µ ${data.project}:
${data.description}
–°—É–º–º–∞: ${data.amount}
${data.money_source ? '–ò—Å—Ç–æ—á–Ω–∏–∫: ' + data.money_source : ''}
–î–∞—Ç–∞: ${data.date}`;
                        await bot.sendMessage(chatId, message);
                    }
                    break;

                case 'task':
                    success = await dataStorage.saveTask(data);
                    if (success) {
                        const message = `‚úÖ –ó–∞–¥–∞—á–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ –ø—Ä–æ–µ–∫—Ç–µ ${data.project}:
${data.description}
${data.person ? '–û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π: ' + data.person : ''}
–°—Ç–∞—Ç—É—Å: ${data.status || '–ù–æ–≤–∞—è'}
–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: ${data.priority || '–°—Ä–µ–¥–Ω–∏–π'}
–î–∞—Ç–∞: ${data.date}`;
                        await bot.sendMessage(chatId, message);
                    }
                    break;

                case 'idea':
                    success = await dataStorage.saveIdea(data);
                    if (success) {
                        let message = `‚úÖ –ò–¥–µ—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ –ø—Ä–æ–µ–∫—Ç–µ ${data.project}:
${data.description}`;
                        
                        if (data.link) {
                            message += `\nüîó –°—Å—ã–ª–∫–∞: ${data.link}`;
                        }
                        if (data.file_name) {
                            message += `\nüìé –§–∞–π–ª: ${data.file_name}`;
                        }
                        
                        await bot.sendMessage(chatId, message);
                    }
                    break;

                case 'reminder':
                    success = await dataStorage.saveReminder(data);
                    if (success) {
                        const message = `‚úÖ –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ:
${data.description}
–í—Ä–µ–º—è: ${new Date(data.remindAt).toLocaleString()}`;
                        await bot.sendMessage(chatId, message);
                    }
                    break;
            }
        } catch (error) {
            console.error('Save data error:', error);
            await bot.sendMessage(chatId, '–ò–∑–≤–∏–Ω–∏—Ç–µ, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö.');
        }
    }
}

// Scheduled task reminders
cron.schedule('0 7,13,19 * * *', async () => {
    try {
        const today = new Date().toISOString().slice(0, 10);
        
        // Get today's tasks from Supabase
        const { data: tasks, error } = await supabase
            .from('tasks')
            .select('*')
            .eq('date', today);

        if (error) {
            console.error('Error fetching tasks:', error);
            return;
        }

        // Group tasks by person
        const tasksByPerson = {};
        tasks.forEach(task => {
            if (task.person) {
                if (!tasksByPerson[task.person]) {
                    tasksByPerson[task.person] = [];
                }
                tasksByPerson[task.person].push(task);
            }
        });

        // Send reminders
        for (const [person, personTasks] of Object.entries(tasksByPerson)) {
            const chatId = aiClassifier.chatMap.get(person);
            if (chatId && personTasks.length > 0) {
                const currentHour = new Date().toLocaleString("en-US", {
                    timeZone: "Europe/Tirane", 
                    hour: "numeric", 
                    hour12: false
                });
                
                let timeIcon = '';
                let timeText = '';
                
                if (currentHour >= 6 && currentHour < 12) {
                    timeIcon = 'üåÖ';
                    timeText = '–î–æ–±—Ä–æ–µ —É—Ç—Ä–æ';
                } else if (currentHour >= 12 && currentHour < 17) {
                    timeIcon = 'üòä';
                    timeText = '–î–æ–±—Ä—ã–π –¥–µ–Ω—å';
                } else if (currentHour >= 17 && currentHour < 22) {
                    timeIcon = 'üåÜ';
                    timeText = '–î–æ–±—Ä—ã–π –≤–µ—á–µ—Ä';
                } else {
                    timeIcon = 'üåô';
                    timeText = '–î–æ–±—Ä–æ–π –Ω–æ—á–∏';
                }

                let message = `${timeIcon} ${timeText}!\n\nüéØ –£ —Ç–µ–±—è –Ω–∞ —Å–µ–≥–æ–¥–Ω—è –∑–∞–¥–∞—á: ${personTasks.length}\n\n`;
                
                personTasks.forEach((task, index) => {
                    message += `${index + 1}. ${task.description}\n`;
                });
                
                message += '\nüí™ –£–¥–∞—á–Ω–æ–≥–æ –¥–Ω—è!';
                
                await bot.sendMessage(chatId, message);
            }
        }
    } catch (error) {
        console.error('Scheduled reminder error:', error);
    }
});

// Webhook endpoint for Telegram
app.post('/webhook', async (req, res) => {
    try {
        const { message } = req.body;
        
        if (!message) {
            return res.json({ ok: true });
        }
        
        // Process message through bot
        await bot.handleUpdate(req.body);
        
        res.json({ ok: true });
    } catch (error) {
        console.error('Webhook error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// API endpoints for web app
app.post('/api/submit', async (req, res) => {
    try {
        const { type, project, description, amount, person, date } = req.body;
        const telegramChatId = req.body.telegramChatId || 'web-app';
        
        const data = {
            type,
            project,
            description,
            amount,
            person,
            date: date || new Date().toISOString().slice(0, 10),
            telegramChatId
        };

        let success = false;
        switch (type) {
            case 'transaction':
                success = await dataStorage.saveTransaction(data);
                break;
            case 'task':
                success = await dataStorage.saveTask(data);
                break;
            case 'idea':
                success = await dataStorage.saveIdea(data);
                break;
        }

        res.json({ success, message: success ? '–î–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã' : '–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è' });
    } catch (error) {
        console.error('API submit error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.get('/api/analytics', async (req, res) => {
    try {
        const { project, period = 'week' } = req.query;
        
        // Calculate date range based on period
        const endDate = new Date();
        let startDate = new Date();
        
        switch (period) {
            case 'week':
                startDate.setDate(endDate.getDate() - 7);
                break;
            case 'month':
                startDate.setMonth(endDate.getMonth() - 1);
                break;
            case 'quarter':
                startDate.setMonth(endDate.getMonth() - 3);
                break;
            case 'year':
                startDate.setFullYear(endDate.getFullYear() - 1);
                break;
        }
        
        // Fetch data from Supabase
        let transactionsQuery = supabase
            .from('transactions')
            .select('*')
            .gte('date', startDate.toISOString().slice(0, 10))
            .lte('date', endDate.toISOString().slice(0, 10));
            
        let tasksQuery = supabase
            .from('tasks')
            .select('*')
            .gte('date', startDate.toISOString().slice(0, 10))
            .lte('date', endDate.toISOString().slice(0, 10));
            
        let ideasQuery = supabase
            .from('ideas')
            .select('*')
            .gte('created_at', startDate.toISOString())
            .lte('created_at', endDate.toISOString());
        
        if (project && project !== 'all') {
            transactionsQuery = transactionsQuery.eq('project', project);
            tasksQuery = tasksQuery.eq('project', project);
            ideasQuery = ideasQuery.eq('project', project);
        }
        
        const [transactionsResult, tasksResult, ideasResult] = await Promise.all([
            transactionsQuery,
            tasksQuery,
            ideasQuery
        ]);
        
        if (transactionsResult.error) throw transactionsResult.error;
        if (tasksResult.error) throw tasksResult.error;
        if (ideasResult.error) throw ideasResult.error;
        
        // Calculate totals
        const totalIncome = transactionsResult.data
            .filter(t => t.amount.startsWith('+'))
            .reduce((sum, t) => sum + parseFloat(t.amount.replace(/[^\d.-]/g, '')), 0);
            
        const totalExpenses = transactionsResult.data
            .filter(t => t.amount.startsWith('-'))
            .reduce((sum, t) => sum + Math.abs(parseFloat(t.amount.replace(/[^\d.-]/g, ''))), 0);
        
        res.json({
            transactions: transactionsResult.data,
            tasks: tasksResult.data,
            ideas: ideasResult.data,
            stats: {
                transactions: transactionsResult.data.length,
                tasks: tasksResult.data.length,
                ideas: ideasResult.data.length,
                totalIncome,
                totalExpenses
            }
        });
    } catch (error) {
        console.error('Analytics error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.get('/api/recent', async (req, res) => {
    try {
        const { data: transactions } = await supabase
            .from('transactions')
            .select('*')
            .order('created_at', { ascending: false })
            .limit(10);
            
        const { data: tasks } = await supabase
            .from('tasks')
            .select('*')
            .order('created_at', { ascending: false })
            .limit(10);
            
        const { data: ideas } = await supabase
            .from('ideas')
            .select('*')
            .order('created_at', { ascending: false })
            .limit(10);
        
        // Combine and sort by creation date
        const allItems = [
            ...(transactions || []).map(item => ({ ...item, type: 'transaction' })),
            ...(tasks || []).map(item => ({ ...item, type: 'task' })),
            ...(ideas || []).map(item => ({ ...item, type: 'idea' }))
        ].sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
        
        res.json(allItems.slice(0, 10));
    } catch (error) {
        console.error('Recent items error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.get('/api/settings', async (req, res) => {
    try {
        // For now, return default settings
        // In a real app, you'd fetch from database
        res.json({
            storage: {
                transaction: {
                    primary: 'supabase',
                    supabase: true,
                    sheets: false,
                    sheets: false
                },
                task: {
                    primary: 'supabase',
                    supabase: true,
                    sheets: false
                },
                idea: {
                    primary: 'supabase',
                    supabase: true,
                    sheets: false
                }
            },
            notifications: {
                personal: true,
                chat: false,
                channel: false,
                chatId: '',
                channelId: ''
            },
            ai: {
                autoClassify: true,
                voiceTranscription: true,
                smartReminders: true
            }
        });
    } catch (error) {
        console.error('Settings error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.post('/api/settings', async (req, res) => {
    try {
        const settings = req.body;
        
        // In a real app, you'd save to database
        console.log('Saving settings:', settings);
        
        // Validate settings structure
        if (!settings.storage || !settings.notifications || !settings.ai) {
            return res.status(400).json({ error: 'Invalid settings structure' });
        }
        
        res.json({ success: true, message: 'Settings saved successfully' });
    } catch (error) {
        console.error('Save settings error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Start server
app.listen(PORT, () => {
    console.log(`üöÄ Telegram AI Assistant server running on port ${PORT}`);
    console.log(`üì± Webhook URL: https://your-domain.com/webhook`);
    console.log(`üîó Web App: https://bespoke-platypus-5c4604.netlify.app/`);
}); 