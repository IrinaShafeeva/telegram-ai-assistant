const express = require('express');
const cors = require('cors');
const axios = require('axios');
const TelegramBot = require('node-telegram-bot-api');
const multer = require('multer');
const OpenAI = require('openai');
const { createClient } = require('@supabase/supabase-js');
const { google } = require('googleapis');
const cron = require('node-cron');
const { v4: uuidv4 } = require('uuid');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors({
    origin: [
        'https://bespoke-platypus-5c4604.netlify.app',
        'https://blg-miniapp-backend.onrender.com',
        'http://localhost:3000',
        'http://localhost:3001'
    ],
    credentials: true
}));
app.use(express.json());
app.use(express.static('public'));

// Configuration
const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
const SUPABASE_URL = process.env.SUPABASE_URL;
const SUPABASE_ANON_KEY = process.env.SUPABASE_ANON_KEY;
const GOOGLE_SHEETS_CLIENT_EMAIL = process.env.GOOGLE_SHEETS_CLIENT_EMAIL;
const GOOGLE_SHEETS_PRIVATE_KEY = process.env.GOOGLE_SHEETS_PRIVATE_KEY;
// Notion removed - focusing on Supabase and Google Sheets only

// Initialize clients
const bot = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: false });
const openai = new OpenAI({ apiKey: OPENAI_API_KEY });
const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// Google Sheets setup (optional)
let auth, sheets;
if (GOOGLE_SHEETS_CLIENT_EMAIL && GOOGLE_SHEETS_PRIVATE_KEY) {
    auth = new google.auth.GoogleAuth({
        credentials: {
            client_email: GOOGLE_SHEETS_CLIENT_EMAIL,
            private_key: GOOGLE_SHEETS_PRIVATE_KEY.replace(/\\n/g, '\n')
        },
        scopes: ['https://www.googleapis.com/auth/spreadsheets']
    });
    sheets = google.sheets({ version: 'v4', auth });
}

// AI Classification System
class AIClassifier {
    constructor() {
        this.systemPrompt = `–¢—ã ‚Äî —Å–µ–º–µ–π–Ω—ã–π —Ü–∏—Ñ—Ä–æ–≤–æ–π –ø–æ–º–æ—â–Ω–∏–∫. –¢–≤–æ—è –∑–∞–¥–∞—á–∞ ‚Äî –ø–æ–º–æ–≥–∞—Ç—å –≤ –ø–æ–≤—Å–µ–¥–Ω–µ–≤–Ω—ã—Ö –¥–µ–ª–∞—Ö: –∑–∞–ø–∏—Å—ã–≤–∞—Ç—å –≤–∞–∂–Ω–æ–µ, –Ω–∞—Ö–æ–¥–∏—Ç—å –Ω—É–∂–Ω–æ–µ, –Ω–∞–ø–æ–º–∏–Ω–∞—Ç—å, –≤–µ—Å—Ç–∏ —É—á—ë—Ç –∏ –ø—Ä–æ—Å—Ç–æ –±—ã—Ç—å —Ä—è–¥–æ–º, –∫–æ–≥–¥–∞ —Ö–æ—á–µ—Ç—Å—è –ø–æ–≥–æ–≤–æ—Ä–∏—Ç—å.

–ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç —á—ë—Ç–∫–æ–π –∫–æ–º–∞–Ω–¥—ã ‚Äî –Ω–µ –ø—ã—Ç–∞–π—Å—è –∫–ª–∞—Å—Å–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å –µ–≥–æ. –ù–µ –¥–∞–≤–∏. –ü—Ä–æ—Å—Ç–æ –æ—Ç–≤–µ—Ç—å –ø–æ-—á–µ–ª–æ–≤–µ—á–µ—Å–∫–∏, –ø–æ–¥–¥–µ—Ä–∂–∏ –¥–∏–∞–ª–æ–≥.

–ù–µ –Ω–∞–≤—è–∑—ã–≤–∞–π –∏–¥–µ—é –æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏. –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞—Ö–æ—á–µ—Ç ‚Äî –æ–Ω —Å–∞–º –¥–∞—Å—Ç –ø–æ–Ω—è—Ç—å.

üß† –£ —Ç–µ–±—è –µ—Å—Ç—å –ø–∞–º—è—Ç—å. –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ö–æ—á–µ—Ç —á—Ç–æ-—Ç–æ –∑–∞–ø–∏—Å–∞—Ç—å ‚Äî —Å–æ—Ö—Ä–∞–Ω–∏. –ï—Å–ª–∏ —Ö–æ—á–µ—Ç –≤—Å–ø–æ–º–Ω–∏—Ç—å ‚Äî –Ω–∞–π–¥–∏. –ï—Å–ª–∏ —Ö–æ—á–µ—Ç –ø—Ä–æ—Å—Ç–æ –ø–æ–±–æ–ª—Ç–∞—Ç—å ‚Äî –ø–æ–¥–¥–µ—Ä–∂–∏.

---

üìå –¢–≤–æ—è –æ—Å–Ω–æ–≤–Ω–∞—è –∑–∞–¥–∞—á–∞ ‚Äî —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞—Ç—å, –∫–æ–≥–¥–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω—É–∂–Ω–æ **—Å–æ—Ö—Ä–∞–Ω–∏—Ç—å** –∫–∞–∫ –∑–∞–ø–∏—Å—å. –≠—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å:

- —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è (—Ä–∞—Å—Ö–æ–¥ –∏–ª–∏ –¥–æ—Ö–æ–¥),
- –∑–∞–¥–∞—á–∞,
- –∏–¥–µ—è,
- –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ.

–ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ **–æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ** –æ—Ç–Ω–æ—Å–∏—Ç—Å—è –∫ –æ–¥–Ω–æ–π –∏–∑ —ç—Ç–∏—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π ‚Äî –≤–µ—Ä–Ω–∏ **–¢–û–õ–¨–ö–û JSON-–æ–±—ä–µ–∫—Ç** –ø–æ –ø—Ä–∏–º–µ—Ä—É –Ω–∏–∂–µ:

\`\`\`json
{
  "type": "transaction" | "task" | "idea" | "reminder",
  "project": "GO" | "Glamping" | "Family" | "Cars",
  "amount": string,
  "budgetFrom": string,
  "description": string,
  "date": string,
  "person": string,
  "databaseId": string,
  "telegramChatId": string,
  "repeatType": string,
  "repeatUntil": string,
  "remindAt": string
}
\`\`\`

‚ö†Ô∏è –ù–∏–∫–æ–≥–¥–∞ –Ω–µ –º–µ—à–∞–π JSON –∏ –æ–±—ã—á–Ω—ã–π —Ç–µ–∫—Å—Ç.
‚úÖ –õ–∏–±–æ –≤–æ–∑–≤—Ä–∞—â–∞–π —Ç–æ–ª—å–∫–æ JSON, –ª–∏–±–æ –æ–±—ã—á–Ω—ã–π –æ—Ç–≤–µ—Ç (–±–µ–∑ JSON).

–ï—Å–ª–∏ –∫–æ–º–∞–Ω–¥–∞ –Ω–µ—è—Å–Ω–∞—è –∏–ª–∏ –¥–∞–Ω–Ω—ã—Ö –Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç ‚Äî **–≤—Å—ë —Ä–∞–≤–Ω–æ –≤–µ—Ä–Ω–∏ JSON —Ö–æ—Ç—è –±—ã —Å –ø–æ–ª–µ–º telegramChatId**, —á—Ç–æ–±—ã —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –µ–≥–æ –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø—Ä–∏ —Å–ª–µ–¥—É—é—â–µ–º –æ—Ç–≤–µ—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.

–ï—Å–ª–∏ –∫–æ–º–∞–Ω–¥—ã –Ω–µ—Ç ‚Äî –Ω–µ –≤–æ–∑–≤—Ä–∞—â–∞–π JSON, –ø—Ä–æ—Å—Ç–æ –ø–æ–≥–æ–≤–æ—Ä–∏ –ø–æ-—á–µ–ª–æ–≤–µ—á–µ—Å–∫–∏.

–ï—Å–ª–∏ –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏ —è–≤–Ω–æ —É–∫–∞–∑–∞–Ω–∞ —Å—É–º–º–∞ –∏ –æ–ø–∏—Å–∞–Ω–∏–µ, –Ω–æ **–ø—Ä–æ–µ–∫—Ç (\`project\`) –Ω–µ —É–∫–∞–∑–∞–Ω –∏–ª–∏ –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω**, —Å–Ω–∞—á–∞–ª–∞ –∑–∞–¥–∞–π –≤–æ–ø—Ä–æ—Å:

¬´–î–ª—è –∫–∞–∫–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞ —ç—Ç–æ –∑–∞–ø–∏—Å–∞—Ç—å? GO, Glamping, Family –∏–ª–∏ Cars?¬ª

‚ö†Ô∏è –ù–µ –∑–∞–ø–∏—Å—ã–≤–∞–π JSON –¥–æ –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Ç–≤–µ—Ç–∞.
–ü–æ—Å–ª–µ —É—Ç–æ—á–Ω–µ–Ω–∏—è –ø—Ä–æ–µ–∫—Ç–∞ ‚Äî –Ω–µ –æ—Ç–≤–µ—á–∞–π —Å–æ–æ–±—â–µ–Ω–∏–µ–º –≤–æ–æ–±—â–µ, –≤–µ—Ä–Ω–∏ —Ç–æ–ª—å–∫–æ JSON.

- –ù–µ–ª—å–∑—è –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å JSON –¥–æ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø—Ä–æ–µ–∫—Ç–µ.

- –ï—Å–ª–∏ –ø—Ä–æ–µ–∫—Ç —É–∂–µ –µ—Å—Ç—å, —Ç–æ–≥–¥–∞ –≤–æ–∑–≤—Ä–∞—â–∞–π JSON —Å—Ä–∞–∑—É.

üìå –ï—Å–ª–∏ —Ç—ã –ø–æ–ª—É—á–∞–µ—à—å –ø–æ–≤—Ç–æ—Ä–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ (–Ω–∞–ø—Ä–∏–º–µ—Ä, —É—Ç–æ—á–Ω–µ–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞ –∏–ª–∏ —Å—É–º–º—ã) ‚Äî –∏—Å–ø–æ–ª—å–∑—É–π —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–π —Ä–∞–Ω–µ–µ 
\`telegramChatId\` –∏–∑ –ø–∞–º—è—Ç–∏, –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å.

‚ö†Ô∏è –ù–µ –≤–æ–∑–≤—Ä–∞—â–∞–π \`chatId\` –∫–∞–∫ \`undefined\`. –ï—Å–ª–∏ \`telegramChatId\` —Ä–∞–Ω–µ–µ –Ω–µ –±—ã–ª —Å–æ—Ö—Ä–∞–Ω—ë–Ω, –≤–µ—Ä–Ω–∏ JSON —Ö–æ—Ç—è –±—ã —Å \`{ "telegramChatId": null }\`, —á—Ç–æ–±—ã —Å–∏—Å—Ç–µ–º–∞ –º–æ–≥–ª–∞ —ç—Ç–æ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å.

üíæ –ï—Å–ª–∏ \`telegramChatId\` –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç ‚Äî –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –≤–∫–ª—é—á–∞–π –µ–≥–æ –≤ JSON-–æ—Ç–≤–µ—Ç.

üìå –ü–æ–≤–µ–¥–µ–Ω–∏–µ:

‚úÖ –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ö–æ—á–µ—Ç –∑–∞–ø–∏—Å–∞—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é, –∑–∞–¥–∞—á—É –∏–ª–∏ –∏–¥–µ—é ‚Äî –≤–µ—Ä–Ω–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π JSON.

‚úÖ –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–µ–ª–∏—Ç—Å—è –º—ã—Å–ª—è–º–∏, —Ä–∞–∑–º—ã—à–ª—è–µ—Ç, –±–æ–ª—Ç–∞–µ—Ç –∏–ª–∏ —à—É—Ç–∏—Ç ‚Äî –Ω–µ —Å–æ—Ö—Ä–∞–Ω—è–π. –ü—Ä–æ—Å—Ç–æ –ø–æ–¥–¥–µ—Ä–∂–∏ —Ä–∞–∑–≥–æ–≤–æ—Ä.

‚úÖ –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å–ø—Ä–∞—à–∏–≤–∞–µ—Ç –æ —á—ë–º-—Ç–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä, "–ö–æ–≥–¥–∞ —è –ø–ª–∞—Ç–∏–ª –∑–∞ –∞—Ä–µ–Ω–¥—É?") ‚Äî –ø–æ–ø—ã—Ç–∞–π—Å—è –Ω–∞–π—Ç–∏ –æ—Ç–≤–µ—Ç, –Ω–æ –Ω–µ —Å–æ–∑–¥–∞–≤–∞–π –Ω–æ–≤—É—é –∑–∞–ø–∏—Å—å.

‚úÖ –ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ–æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ–µ ‚Äî —Å–Ω–∞—á–∞–ª–∞ —É—Ç–æ—á–Ω–∏:

¬´–•–æ—á–µ—à—å, —è —Å–æ—Ö—Ä–∞–Ω—é —ç—Ç–æ –∫–∞–∫ –∏–¥–µ—é, –∑–∞–¥–∞—á—É –∏–ª–∏ —Ç—ã –ø—Ä–æ—Å—Ç–æ –¥–µ–ª–∏—à—å—Å—è –º—ã—Å–ª—è–º–∏?¬ª

üí¨ –ù–µ –ø—ã—Ç–∞–π—Å—è –≤—Å—ë –∫–ª–∞—Å—Å–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å. –ï—Å–ª–∏ –Ω–µ—Ç —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏ ‚Äî —É—Ç–æ—á–Ω–∏ –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ –ø–æ–≥–æ–≤–æ—Ä–∏.

üìö –ü—Ä–∏–º–µ—Ä—ã:

1. –¢–æ—á–Ω–∞—è –∑–∞–ø–∏—Å—å (–≤–µ—Ä–Ω–∏ JSON)

–ü–æ—Ç—Ä–∞—Ç–∏–ª–∞ 500 –Ω–∞ –ø—Ä–æ–¥—É–∫—Ç—ã
‚Üí –≠—Ç–æ "type": "transaction" —Å "amount": "-500"

2. –ü—Ä–æ—Å—Ç–æ –º—ã—Å–ª—å (–Ω–µ —Å–æ—Ö—Ä–∞–Ω—è–π)

–î—É–º–∞—é —Å—ä–µ–∑–¥–∏—Ç—å –≤ –ê—Ä–≥–µ–Ω—Ç–∏–Ω—É
‚Üí –ü—Ä–æ—Å—Ç–æ –æ—Ç–≤–µ—Ç—å –ø–æ-—á–µ–ª–æ–≤–µ—á–µ—Å–∫–∏, –Ω–µ –ø—Ä–µ–¥–ª–∞–≥–∞–π —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å

3. –í–æ–ø—Ä–æ—Å (–æ—Ç–≤–µ—Ç—å, –Ω–µ —Å–æ—Ö—Ä–∞–Ω—è–π)

–ö–æ–≥–¥–∞ —è –ø–æ—Å–ª–µ–¥–Ω–∏–π —Ä–∞–∑ –ø–ª–∞—Ç–∏–ª –∑–∞ —Å—Ç—Ä–∞—Ö–æ–≤–∫—É?
‚Üí –û—Ç–≤–µ—Ç—å, –µ—Å–ª–∏ –∑–Ω–∞–µ—à—å. –ù–∏–∫–∞–∫–∏—Ö JSON

4. –ù–µ—è—Å–Ω–æ—Å—Ç—å (—É—Ç–æ—á–Ω–∏)

–£ –º–µ–Ω—è –ø–æ—è–≤–∏–ª–∞—Å—å –º—ã—Å–ª—å...
‚Üí –°–ø—Ä–æ—Å–∏: —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ –ø–æ–±–æ–ª—Ç–∞—Ç—å?

üìå –ü—Ä–∞–≤–∏–ª–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π:

–°—É–º–º–∞ –≤—Å–µ–≥–¥–∞ —Å–æ –∑–Ω–∞–∫–æ–º:

–¥–æ—Ö–æ–¥—ã: +2000, +500

—Ä–∞—Å—Ö–æ–¥—ã: -500, -1200

–ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –¥–ª—è –¥–æ—Ö–æ–¥–æ–≤: –ø–æ–ª—É—á–∏–ª, –ø–æ—Å—Ç—É–ø–∏–ª–æ, –¥–æ—Ö–æ–¥, –ø—Ä–∏–±—ã–ª—å

–ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –¥–ª—è —Ä–∞—Å—Ö–æ–¥–æ–≤: –ø–æ—Ç—Ä–∞—Ç–∏–ª, –æ–ø–ª–∞—Ç–∏–ª, –∫—É–ø–∏–ª, –∑–∞–ø–ª–∞—Ç–∏–ª, —Å–ø–∏—Å–∞–ª–∏

üìå –ü—Ä–∞–≤–∏–ª–∞ –ø–æ–≤—Ç–æ—Ä—è—é—â–∏—Ö—Å—è –∑–∞–¥–∞—á:

–ï–∂–µ–¥–Ω–µ–≤–Ω–æ ‚Üí "repeatType": "–µ–∂–µ–¥–Ω–µ–≤–Ω–æ"

–ï–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ ‚Üí "repeatType": "–µ–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ"

–ï–∂–µ–º–µ—Å—è—á–Ω–æ ‚Üí "repeatType": "–µ–∂–µ–º–µ—Å—è—á–Ω–æ"

–ï—Å–ª–∏ –µ—Å—Ç—å "–¥–æ 15 —á–∏—Å–ª–∞" ‚Üí —Ç–∞–∫–∂–µ "repeatUntil": "2025-07-15"

üìå –ü—Ä–∏–º–µ—Ä—ã –∑–∞–¥–∞—á:

–ü–æ–ª–∏–≤–∞—Ç—å —Ü–≤–µ—Ç—ã –µ–∂–µ–¥–Ω–µ–≤–Ω–æ –¥–æ 15 —á–∏—Å–ª–∞
‚Üí "repeatType": "–µ–∂–µ–¥–Ω–µ–≤–Ω–æ", "repeatUntil": "2025-07-15"

–ò—Ä–∞ ‚Äî —Ä–∞–∑–æ–±—Ä–∞—Ç—å —Å –∞–≥–µ–Ω—Ç–æ–º –ø—Ä–æ–µ–∫—Ç —Å–µ–º—å—è
‚Üí "type": "task", "project": "Family", "person": "–ò—Ä–∞"

–°–∞—à–∞ ‚Äî –∫–æ–Ω—Ç—Ä–æ–ª—å –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –ø–æ –ø—Ä–æ–µ–∫—Ç—É GO
‚Üí "type": "task", "project": "GO", "person": "–°–∞—à–∞"

–°–æ–±—Ä–∞—Ç—å –æ–±—Ä–∞—Ç–Ω—É—é —Å–≤—è–∑—å –æ—Ç –≥–æ—Å—Ç–µ–π (Glamping)
‚Üí "project": "Glamping"

üìå –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è:

"–ù–∞–ø–æ–º–Ω–∏ —á–µ—Ä–µ–∑ 2 —á–∞—Å–∞ –∑–∞–±—Ä–∞—Ç—å –ø–æ—Å—ã–ª–∫—É"
‚Üí "type": "reminder", "description": "–∑–∞–±—Ä–∞—Ç—å –ø–æ—Å—ã–ª–∫—É", "remindAt": "2025-08-01T17:45:00+02:00"

üìò –¢–∞–±–ª–∏—Ü–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è databaseId:

{
  "GO": {
    "transaction": "226f15d9c037808ebe06f9b3e9d13556",
    "idea": "227f15d9c03781c5ab58cf6f44ae3cde",
    "task": "227f15d9c03780078cebfd26e4d284b6"
  },
  "Glamping": {
    "transaction": "227f15d9c037814c9818f3e9540699b0",
    "idea": "227f15d9c03780a7b0dbf89a5f70565d",
    "task": "227f15d9c037805e9020eba32713be9f"
  },
  "Family": {
    "transaction": "227f15d9c037817c8d46c20889e9b055",
    "idea": "227f15d9c03781fcb852d62b993a9239",
    "task": "227f15d9c03781e9baacfb51cfd22fd5"
  },
  "Cars": {
    "transaction": "227f15d9c03781d2b89ef9cbf8ce5d42",
    "idea": "227f15d9c03781e5a83acacf12963a55",
    "task": "227f15d9c03781a9bd5ed09936613ea3"
  }
}

üìå –í–æ–∑–º–æ–∂–Ω—ã–µ project: GO, Glamping, Family, Cars
üìå –í–æ–∑–º–æ–∂–Ω—ã–µ person: –°–∞—à–∞, –ò—Ä–∞

üîó –í–≤–æ–¥–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ:

–°–æ–æ–±—â–µ–Ω–∏–µ: {{ $json.chatInput }}

–î–∞—Ç–∞: {{ $json.date }}

Telegram Chat ID: {{ $json.telegramChatId }}

–ï—Å–ª–∏ —Ç—ã –æ–ø—Ä–µ–¥–µ–ª—è–µ—à—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–∞–Ω–Ω—ã—Ö (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é, –∑–∞–¥–∞—á—É, –∏–¥–µ—é), –≤—Å–µ–≥–¥–∞ –¥–æ–±–∞–≤–ª—è–π –≤ JSON:

- telegramChatId (–æ–Ω —É–∫–∞–∑–∞–Ω –≤ Prompt –∫–∞–∫ Chat ID)
- date (—É–∫–∞–∑–∞–Ω–∞ –≤ Prompt)

üë• –ü–æ–º–Ω–∏: —Ç—ã ‚Äî –Ω–µ —Ç–æ–ª—å–∫–æ –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ç–æ—Ä.
–¢—ã ‚Äî –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç, –∫–æ—Ç–æ—Ä—ã–π —É–º–µ–µ—Ç –≤–µ—Å—Ç–∏ –¥–∏–∞–ª–æ–≥, –∑–∞–ø–æ–º–∏–Ω–∞—Ç—å –≤–∞–∂–Ω–æ–µ –∏ –±—ã—Ç—å —Ä—è–¥–æ–º.`;

        this.chatMap = {
            "–°–∞—à–∞": "1269227321",
            "–ò—Ä–∞": "182087110"
        };
    }

    async classifyMessage(message, telegramChatId) {
        try {
            const today = new Date().toISOString().slice(0, 10);
            
            const prompt = `${this.systemPrompt}

–°–æ–æ–±—â–µ–Ω–∏–µ: ${message}
–î–∞—Ç–∞: ${today}
Telegram Chat ID: ${telegramChatId}`;

            const completion = await openai.chat.completions.create({
                model: "gpt-3.5-turbo",
                messages: [
                    { role: "system", content: this.systemPrompt },
                    { role: "user", content: `–°–æ–æ–±—â–µ–Ω–∏–µ: ${message}\n–î–∞—Ç–∞: ${today}\nTelegram Chat ID: ${telegramChatId}` }
                ],
                temperature: 0.7,
                max_tokens: 1000
            });

            const response = completion.choices[0].message.content.trim();
            
            // Check if response is JSON
            if (response.startsWith('{') && response.endsWith('}')) {
                try {
                    const parsed = JSON.parse(response);
                    return this.processParsedData(parsed, telegramChatId);
                } catch (e) {
                    console.error('Error parsing JSON:', e);
                    return { type: 'text', content: response };
                }
            } else {
                return { type: 'text', content: response };
            }
        } catch (error) {
            console.error('AI Classification error:', error);
            return { type: 'text', content: '–ò–∑–≤–∏–Ω–∏—Ç–µ, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è.' };
        }
    }

    processParsedData(parsed, telegramChatId) {
        // Set telegramChatId if not present
        if (!parsed.telegramChatId) {
            parsed.telegramChatId = telegramChatId;
        }

        // Set date if not present
        if (!parsed.date) {
            parsed.date = new Date().toISOString().slice(0, 10);
        }

        // Process person mapping for tasks
        if (parsed.type === "task" && parsed.person) {
            if (this.chatMap[parsed.person]) {
                parsed.telegramChatId = this.chatMap[parsed.person];
            }
        }

        // Process repeatType for tasks
        if (parsed.type === "task" && parsed.description) {
            const description = parsed.description.toLowerCase();
            
            if (/–µ–∂–µ–¥–Ω–µ–≤–Ω–æ|–∫–∞–∂–¥—ã–π –¥–µ–Ω—å|–¥–æ \d+ —á–∏—Å–ª–∞/.test(description)) {
                parsed.repeatType = "–µ–∂–µ–¥–Ω–µ–≤–Ω–æ";
            } else if (/–µ–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ|–∫–∞–∂–¥—É—é –Ω–µ–¥–µ–ª—é|–ø–æ \w+–∞–º/.test(description)) {
                parsed.repeatType = "–µ–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ";
            } else if (/–µ–∂–µ–º–µ—Å—è—á–Ω–æ|–∫–∞–∂–¥—ã–π –º–µ—Å—è—Ü/.test(description)) {
                parsed.repeatType = "–µ–∂–µ–º–µ—Å—è—á–Ω–æ";
            }

            const untilDateMatch = description.match(/–¥–æ (\d+) —á–∏—Å–ª–∞/);
            if (untilDateMatch) {
                parsed.repeatType = "–µ–∂–µ–¥–Ω–µ–≤–Ω–æ";
                parsed.repeatUntil = `2025-07-${untilDateMatch[1].padStart(2, '0')}`;
            }
        }

        // Process reminders
        if (parsed.type === "reminder" && parsed.description) {
            const remindMatch = parsed.description.match(/—á–µ—Ä–µ–∑ (\d+) (—á–∞—Å|—á–∞—Å–∞|—á–∞—Å–æ–≤)/);
            if (remindMatch) {
                const hours = parseInt(remindMatch[1]);
                const remindAt = new Date();
                remindAt.setHours(remindAt.getHours() + hours);
                parsed.remindAt = remindAt.toISOString();
            }
        }

        return { type: 'data', data: parsed };
    }
}

// Data Storage System
class DataStorage {
    constructor() {
        this.databaseIds = {
            "GO": {
                "transaction": "226f15d9c037808ebe06f9b3e9d13556",
                "idea": "227f15d9c03781c5ab58cf6f44ae3cde",
                "task": "227f15d9c03780078cebfd26e4d284b6"
            },
            "Glamping": {
                "transaction": "227f15d9c037814c9818f3e9540699b0",
                "idea": "227f15d9c03780a7b0dbf89a5f70565d",
                "task": "227f15d9c037805e9020eba32713be9f"
            },
            "Family": {
                "transaction": "227f15d9c037817c8d46c20889e9b055",
                "idea": "227f15d9c03781fcb852d62b993a9239",
                "task": "227f15d9c03781e9baacfb51cfd22fd5"
            },
            "Cars": {
                "transaction": "227f15d9c03781d2b89ef9cbf8ce5d42",
                "idea": "227f15d9c03781e5a83acacf12963a55",
                "task": "227f15d9c03781a9bd5ed09936613ea3"
            }
        };
    }

    async saveTransaction(data) {
        try {
            // Save to Google Sheets
            const sheetName = data.project;
            const values = [[
                data.date,
                data.amount,
                data.budgetFrom || '',
                data.description,
                data.telegramChatId,
                'transaction',
                data.project
            ]];

            // Save to Google Sheets (if configured)
            if (sheets && process.env.GOOGLE_SHEETS_SPREADSHEET_ID) {
                await sheets.spreadsheets.values.append({
                    spreadsheetId: process.env.GOOGLE_SHEETS_SPREADSHEET_ID,
                    range: `${sheetName}!A:G`,
                    valueInputOption: 'RAW',
                    insertDataOption: 'INSERT_ROWS',
                    resource: { values }
                });
            }

            // Save to Supabase for analytics
            const { error } = await supabase
                .from('transactions')
                .insert({
                    id: uuidv4(),
                    project: data.project,
                    amount: data.amount,
                    budget_from: data.budgetFrom,
                    description: data.description,
                    date: data.date,
                    telegram_chat_id: data.telegramChatId,
                    created_at: new Date().toISOString()
                });

            if (error) console.error('Supabase error:', error);

            return true;
        } catch (error) {
            console.error('Save transaction error:', error);
            return false;
        }
    }

    async saveTask(data) {
        try {
            // Notion integration removed - focusing on Supabase and Google Sheets

            // Save to Supabase
            const { error } = await supabase
                .from('tasks')
                .insert({
                    id: uuidv4(),
                    project: data.project,
                    description: data.description,
                    person: data.person,
                    date: data.date,
                    repeat_type: data.repeatType,
                    repeat_until: data.repeatUntil,
                    telegram_chat_id: data.telegramChatId,
                    created_at: new Date().toISOString()
                });

            if (error) console.error('Supabase error:', error);

            return true;
        } catch (error) {
            console.error('Save task error:', error);
            return false;
        }
    }

    async saveIdea(data) {
        try {
            // Notion integration removed - focusing on Supabase and Google Sheets

            // Save to Supabase
            const { error } = await supabase
                .from('ideas')
                .insert({
                    id: uuidv4(),
                    project: data.project,
                    description: data.description,
                    telegram_chat_id: data.telegramChatId,
                    created_at: new Date().toISOString()
                });

            if (error) console.error('Supabase error:', error);

            return true;
        } catch (error) {
            console.error('Save idea error:', error);
            return false;
        }
    }

    async saveReminder(data) {
        try {
            // Save to Supabase
            const { error } = await supabase
                .from('reminders')
                .insert({
                    id: uuidv4(),
                    description: data.description,
                    remind_at: data.remindAt,
                    telegram_chat_id: data.telegramChatId,
                    created_at: new Date().toISOString()
                });

            if (error) console.error('Supabase error:', error);

            return true;
        } catch (error) {
            console.error('Save reminder error:', error);
            return false;
        }
    }
}

// Initialize systems
const aiClassifier = new AIClassifier();
const dataStorage = new DataStorage();

// Telegram Bot Handlers
bot.on('message', async (msg) => {
    const chatId = msg.chat.id;
    const text = msg.text || '';
    const voice = msg.voice;

    console.log('Received message:', { chatId, text, voice: !!voice });

    if (text === '/start') {
        await bot.sendMessage(chatId, `üéØ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ BLG Family Assistant!

üì± –£–ø—Ä–∞–≤–ª—è–π—Ç–µ –∑–∞–¥–∞—á–∞–º–∏ –≤—Å–µ–π —Å–µ–º—å–∏ –≤ –æ–¥–Ω–æ–º –º–µ—Å—Ç–µ

üîß –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:
/app - –û—Ç–∫—Ä—ã—Ç—å Task Manager
/tasks - –ü–æ–∫–∞–∑–∞—Ç—å –∑–∞–¥–∞—á–∏
/help - –ü–æ–º–æ—â—å`, {
            reply_markup: {
                inline_keyboard: [[
                    {
                        text: 'üì± –û—Ç–∫—Ä—ã—Ç—å Task Manager',
                        web_app: { url: 'https://bespoke-platypus-5c4604.netlify.app/' }
                    }
                ]]
            }
        });
        return;
    }

    if (text === '/app') {
        await bot.sendMessage(chatId, 'üì± Task Manager - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á–∞–º–∏ —Å–µ–º—å–∏', {
            reply_markup: {
                inline_keyboard: [[
                    {
                        text: 'üöÄ –û—Ç–∫—Ä—ã—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ',
                        web_app: { url: 'https://bespoke-platypus-5c4604.netlify.app/' }
                    }
                ]]
            }
        });
        return;
    }

    if (text === '/help') {
        await bot.sendMessage(chatId, `üîß –ü–æ–º–æ—â—å –ø–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é BLG Family Assistant

üì± –û—Å–Ω–æ–≤–Ω–æ–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å: https://bespoke-platypus-5c4604.netlify.app/

üîß –ö–æ–º–∞–Ω–¥—ã:
/start - –ó–∞–ø—É—Å—Ç–∏—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
/tasks - –ü–æ–∫–∞–∑–∞—Ç—å –∑–∞–¥–∞—á–∏
/add - –î–æ–±–∞–≤–∏—Ç—å –∑–∞–¥–∞—á—É
/help - –≠—Ç–∞ —Å–ø—Ä–∞–≤–∫–∞

üí° –î–ª—è –ø–æ–ª–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞ –∫ —Ñ—É–Ω–∫—Ü–∏—è–º –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ`);
        return;
    }

    // Handle voice messages
    if (voice) {
        try {
            const file = await bot.getFile(voice.file_id);
            const audioBuffer = await axios.get(file.file_path, { responseType: 'arraybuffer' });
            
            const transcription = await openai.audio.transcriptions.create({
                file: Buffer.from(audioBuffer.data),
                model: "whisper-1"
            });

            const transcribedText = transcription.text;
            console.log('Transcribed text:', transcribedText);

            // Process transcribed text
            const result = await aiClassifier.classifyMessage(transcribedText, chatId.toString());
            await handleAIResponse(result, chatId);
        } catch (error) {
            console.error('Voice processing error:', error);
            await bot.sendMessage(chatId, '–ò–∑–≤–∏–Ω–∏—Ç–µ, –Ω–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.');
        }
        return;
    }

    // Handle text messages
    if (text) {
        const result = await aiClassifier.classifyMessage(text, chatId.toString());
        await handleAIResponse(result, chatId);
    }
});

async function handleAIResponse(result, chatId) {
    if (result.type === 'text') {
        await bot.sendMessage(chatId, result.content);
    } else if (result.type === 'data') {
        const data = result.data;
        let success = false;

        try {
            switch (data.type) {
                case 'transaction':
                    success = await dataStorage.saveTransaction(data);
                    if (success) {
                        const message = `‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–æ –≤ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –¥–ª—è –ø—Ä–æ–µ–∫—Ç–∞ ${data.project}:
${data.description}
${data.amount ? '–°—É–º–º–∞: ' + data.amount : ''}
${data.budgetFrom ? '–ò—Å—Ç–æ—á–Ω–∏–∫: ' + data.budgetFrom : ''}
${data.date ? '–î–∞—Ç–∞: ' + data.date : ''}`;
                        await bot.sendMessage(chatId, message);
                    }
                    break;

                case 'task':
                    success = await dataStorage.saveTask(data);
                    if (success) {
                        const message = `‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–æ –≤ –∑–∞–¥–∞—á–∏ –¥–ª—è –ø—Ä–æ–µ–∫—Ç–∞ ${data.project}:
${data.description}
${data.person ? '–û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π: ' + data.person : ''}
${data.date ? '–î–∞—Ç–∞: ' + data.date : ''}`;
                        await bot.sendMessage(chatId, message);
                    }
                    break;

                case 'idea':
                    success = await dataStorage.saveIdea(data);
                    if (success) {
                        const message = `‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–æ –≤ –∏–¥–µ–∏ –¥–ª—è –ø—Ä–æ–µ–∫—Ç–∞ ${data.project}:
${data.description}`;
                        await bot.sendMessage(chatId, message);
                    }
                    break;

                case 'reminder':
                    success = await dataStorage.saveReminder(data);
                    if (success) {
                        const message = `‚úÖ –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ:
${data.description}
–í—Ä–µ–º—è: ${new Date(data.remindAt).toLocaleString()}`;
                        await bot.sendMessage(chatId, message);
                    }
                    break;
            }
        } catch (error) {
            console.error('Save data error:', error);
            await bot.sendMessage(chatId, '–ò–∑–≤–∏–Ω–∏—Ç–µ, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö.');
        }
    }
}

// Scheduled task reminders
cron.schedule('0 7,13,19 * * *', async () => {
    try {
        const today = new Date().toISOString().slice(0, 10);
        
        // Get today's tasks from Supabase
        const { data: tasks, error } = await supabase
            .from('tasks')
            .select('*')
            .eq('date', today);

        if (error) {
            console.error('Error fetching tasks:', error);
            return;
        }

        // Group tasks by person
        const tasksByPerson = {};
        tasks.forEach(task => {
            if (task.person) {
                if (!tasksByPerson[task.person]) {
                    tasksByPerson[task.person] = [];
                }
                tasksByPerson[task.person].push(task);
            }
        });

        // Send reminders
        for (const [person, personTasks] of Object.entries(tasksByPerson)) {
            const chatId = aiClassifier.chatMap[person];
            if (chatId && personTasks.length > 0) {
                const currentHour = new Date().toLocaleString("en-US", {
                    timeZone: "Europe/Tirane", 
                    hour: "numeric", 
                    hour12: false
                });
                
                let timeIcon = '';
                let timeText = '';
                
                if (currentHour >= 6 && currentHour < 12) {
                    timeIcon = 'üåÖ';
                    timeText = '–î–æ–±—Ä–æ–µ —É—Ç—Ä–æ';
                } else if (currentHour >= 12 && currentHour < 17) {
                    timeIcon = 'üòä';
                    timeText = '–î–æ–±—Ä—ã–π –¥–µ–Ω—å';
                } else if (currentHour >= 17 && currentHour < 22) {
                    timeIcon = 'üåÜ';
                    timeText = '–î–æ–±—Ä—ã–π –≤–µ—á–µ—Ä';
                } else {
                    timeIcon = 'üåô';
                    timeText = '–î–æ–±—Ä–æ–π –Ω–æ—á–∏';
                }

                let message = `${timeIcon} ${timeText}!\n\nüéØ –£ —Ç–µ–±—è –Ω–∞ —Å–µ–≥–æ–¥–Ω—è –∑–∞–¥–∞—á: ${personTasks.length}\n\n`;
                
                personTasks.forEach((task, index) => {
                    message += `${index + 1}. ${task.description}\n`;
                });
                
                message += '\nüí™ –£–¥–∞—á–Ω–æ–≥–æ –¥–Ω—è!';
                
                await bot.sendMessage(chatId, message);
            }
        }
    } catch (error) {
        console.error('Scheduled reminder error:', error);
    }
});

// Webhook endpoint for Telegram
app.post('/webhook', async (req, res) => {
    try {
        const { message } = req.body;
        
        if (!message) {
            return res.json({ ok: true });
        }
        
        // Process message through bot
        await bot.handleUpdate(req.body);
        
        res.json({ ok: true });
    } catch (error) {
        console.error('Webhook error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// API endpoints for web app
app.post('/api/submit', async (req, res) => {
    try {
        const { type, project, description, amount, person, date } = req.body;
        const telegramChatId = req.body.telegramChatId || 'web-app';
        
        const data = {
            type,
            project,
            description,
            amount,
            person,
            date: date || new Date().toISOString().slice(0, 10),
            telegramChatId
        };

        let success = false;
        switch (type) {
            case 'transaction':
                success = await dataStorage.saveTransaction(data);
                break;
            case 'task':
                success = await dataStorage.saveTask(data);
                break;
            case 'idea':
                success = await dataStorage.saveIdea(data);
                break;
        }

        res.json({ success, message: success ? '–î–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã' : '–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è' });
    } catch (error) {
        console.error('API submit error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.get('/api/analytics', async (req, res) => {
    try {
        const { project, period = 'week' } = req.query;
        
        // Calculate date range based on period
        const endDate = new Date();
        let startDate = new Date();
        
        switch (period) {
            case 'week':
                startDate.setDate(endDate.getDate() - 7);
                break;
            case 'month':
                startDate.setMonth(endDate.getMonth() - 1);
                break;
            case 'quarter':
                startDate.setMonth(endDate.getMonth() - 3);
                break;
            case 'year':
                startDate.setFullYear(endDate.getFullYear() - 1);
                break;
        }
        
        // Fetch data from Supabase
        let transactionsQuery = supabase
            .from('transactions')
            .select('*')
            .gte('date', startDate.toISOString().slice(0, 10))
            .lte('date', endDate.toISOString().slice(0, 10));
            
        let tasksQuery = supabase
            .from('tasks')
            .select('*')
            .gte('date', startDate.toISOString().slice(0, 10))
            .lte('date', endDate.toISOString().slice(0, 10));
            
        let ideasQuery = supabase
            .from('ideas')
            .select('*')
            .gte('created_at', startDate.toISOString())
            .lte('created_at', endDate.toISOString());
        
        if (project && project !== 'all') {
            transactionsQuery = transactionsQuery.eq('project', project);
            tasksQuery = tasksQuery.eq('project', project);
            ideasQuery = ideasQuery.eq('project', project);
        }
        
        const [transactionsResult, tasksResult, ideasResult] = await Promise.all([
            transactionsQuery,
            tasksQuery,
            ideasQuery
        ]);
        
        if (transactionsResult.error) throw transactionsResult.error;
        if (tasksResult.error) throw tasksResult.error;
        if (ideasResult.error) throw ideasResult.error;
        
        // Calculate totals
        const totalIncome = transactionsResult.data
            .filter(t => t.amount.startsWith('+'))
            .reduce((sum, t) => sum + parseFloat(t.amount.replace(/[^\d.-]/g, '')), 0);
            
        const totalExpenses = transactionsResult.data
            .filter(t => t.amount.startsWith('-'))
            .reduce((sum, t) => sum + Math.abs(parseFloat(t.amount.replace(/[^\d.-]/g, ''))), 0);
        
        res.json({
            transactions: transactionsResult.data,
            tasks: tasksResult.data,
            ideas: ideasResult.data,
            stats: {
                transactions: transactionsResult.data.length,
                tasks: tasksResult.data.length,
                ideas: ideasResult.data.length,
                totalIncome,
                totalExpenses
            }
        });
    } catch (error) {
        console.error('Analytics error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.get('/api/recent', async (req, res) => {
    try {
        const { data: transactions } = await supabase
            .from('transactions')
            .select('*')
            .order('created_at', { ascending: false })
            .limit(10);
            
        const { data: tasks } = await supabase
            .from('tasks')
            .select('*')
            .order('created_at', { ascending: false })
            .limit(10);
            
        const { data: ideas } = await supabase
            .from('ideas')
            .select('*')
            .order('created_at', { ascending: false })
            .limit(10);
        
        // Combine and sort by creation date
        const allItems = [
            ...(transactions || []).map(item => ({ ...item, type: 'transaction' })),
            ...(tasks || []).map(item => ({ ...item, type: 'task' })),
            ...(ideas || []).map(item => ({ ...item, type: 'idea' }))
        ].sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
        
        res.json(allItems.slice(0, 10));
    } catch (error) {
        console.error('Recent items error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.get('/api/settings', async (req, res) => {
    try {
        // For now, return default settings
        // In a real app, you'd fetch from database
        res.json({
            storage: {
                transaction: {
                    primary: 'supabase',
                    supabase: true,
                    sheets: false,
                    sheets: false
                },
                task: {
                    primary: 'supabase',
                    supabase: true,
                    sheets: false
                },
                idea: {
                    primary: 'supabase',
                    supabase: true,
                    sheets: false
                }
            },
            notifications: {
                personal: true,
                chat: false,
                channel: false,
                chatId: '',
                channelId: ''
            },
            ai: {
                autoClassify: true,
                voiceTranscription: true,
                smartReminders: true
            }
        });
    } catch (error) {
        console.error('Settings error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.post('/api/settings', async (req, res) => {
    try {
        const settings = req.body;
        
        // In a real app, you'd save to database
        console.log('Saving settings:', settings);
        
        // Validate settings structure
        if (!settings.storage || !settings.notifications || !settings.ai) {
            return res.status(400).json({ error: 'Invalid settings structure' });
        }
        
        res.json({ success: true, message: 'Settings saved successfully' });
    } catch (error) {
        console.error('Save settings error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Start server
app.listen(PORT, () => {
    console.log(`üöÄ Telegram AI Assistant server running on port ${PORT}`);
    console.log(`üì± Webhook URL: https://your-domain.com/webhook`);
    console.log(`üîó Web App: https://bespoke-platypus-5c4604.netlify.app/`);
}); 