const OpenAI = require('openai');
const FormData = require('form-data');
const axios = require('axios');
const { EXPENSE_PARSING_PROMPT, ANALYTICS_PROMPT } = require('../config/constants');
const logger = require('../utils/logger');

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

class OpenAIService {
  async transcribeVoice(audioBuffer, mimeType = 'audio/ogg') {
    try {
      const formData = new FormData();
      formData.append('file', audioBuffer, {
        filename: 'voice.ogg',
        contentType: mimeType,
      });
      formData.append('model', 'whisper-1');
      formData.append('language', 'ru');

      const response = await axios.post('https://api.openai.com/v1/audio/transcriptions', formData, {
        headers: {
          'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
          ...formData.getHeaders(),
        },
      });

      return response.data.text;
    } catch (error) {
      logger.error('Voice transcription failed:', error);
      throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ');
    }
  }

  async parseExpense(userInput, userPatterns = null) {
    try {
      let prompt = EXPENSE_PARSING_PROMPT.replace('{{userInput}}', userInput);
      
      // Add smart defaults context if available
      if (userPatterns && userPatterns.length > 0) {
        const patternsContext = userPatterns.map(p => 
          `"${p.keyword}" ‚Üí ${p.category} (${p.avg_amount} ${p.currency})`
        ).join('\n');
        
        prompt += `\n\n–ò—Å—Ç–æ—Ä–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è —Ç–æ—á–Ω–æ—Å—Ç–∏):\n${patternsContext}`;
      }

      const completion = await openai.chat.completions.create({
        model: 'gpt-4',
        messages: [
          {
            role: 'system',
            content: '–¢—ã –ø–æ–º–æ—â–Ω–∏–∫ –ø–æ –∞–Ω–∞–ª–∏–∑—É —Ç—Ä–∞—Ç. –í–æ–∑–≤—Ä–∞—â–∞–π —Ç–æ–ª—å–∫–æ –≤–∞–ª–∏–¥–Ω—ã–π JSON –±–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.1,
        max_tokens: 200
      });

      const result = completion.choices[0].message.content.trim();
      
      // Remove markdown code blocks if present
      const cleanResult = result.replace(/```json\n?|\n?```/g, '');
      
      try {
        const parsed = JSON.parse(cleanResult);
        
        // Validate required fields
        if (!parsed.amount || isNaN(parsed.amount)) {
          throw new Error('Invalid amount');
        }
        
        // Clean and validate data
        return {
          amount: parseFloat(parsed.amount),
          currency: parsed.currency || null,
          description: parsed.description || '–†–∞—Å—Ö–æ–¥',
          category: parsed.category || null
        };
      } catch (parseError) {
        logger.error('Failed to parse OpenAI response:', result);
        throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–Ω—è—Ç—å —Å—É–º–º—É —Ä–∞—Å—Ö–æ–¥–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –Ω–∞–ø–∏—Å–∞—Ç—å —è—Å–Ω–µ–µ.');
      }
    } catch (error) {
      logger.error('Expense parsing failed:', error);
      throw error;
    }
  }

  async analyzeExpenses(userQuestion, expensesData, userId) {
    try {
      // Prepare expense data for context
      const expenseContext = expensesData.map(exp => 
        `${exp.expense_date}: ${exp.description} - ${exp.amount} ${exp.currency} (${exp.category})`
      ).join('\n');

      const prompt = ANALYTICS_PROMPT
        .replace('{{userQuestion}}', userQuestion)
        .replace('{{expenseData}}', expenseContext || '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ —Ä–∞—Å—Ö–æ–¥–∞—Ö');

      const completion = await openai.chat.completions.create({
        model: 'gpt-4',
        messages: [
          {
            role: 'system',
            content: '–¢—ã AI-–∞–Ω–∞–ª–∏—Ç–∏–∫ –ª–∏—á–Ω—ã—Ö —Ñ–∏–Ω–∞–Ω—Å–æ–≤. –î–∞–≤–∞–π –∫—Ä–∞—Ç–∫–∏–µ, –ø–æ–ª–µ–∑–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã —Å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º–∏ —Ü–∏—Ñ—Ä–∞–º–∏ –∏ –∏–Ω—Å–∞–π—Ç–∞–º–∏. –ò—Å–ø–æ–ª—å–∑—É–π —ç–º–æ–¥–∑–∏ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.3,
        max_tokens: 500
      });

      return completion.choices[0].message.content.trim();
    } catch (error) {
      logger.error('Expense analysis failed:', error);
      throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Ä–∞—Å—Ö–æ–¥—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
    }
  }

  async analyzeExpensesWithData(userQuestion, analyticsData, userId) {
    try {
      const categoryList = analyticsData.categoryBreakdown
        .map(cat => `${cat.category}: ${cat.formatted} (${cat.percentage}%)`)
        .join('\n');
      
      const monthlyList = analyticsData.monthlyBreakdown
        .map(month => `${month.month}: ${month.formatted}`)
        .join('\n');

      const prompt = `–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å–ø—Ä–∞—à–∏–≤–∞–µ—Ç: "${userQuestion}"

–¢–û–ß–ù–´–ï –î–ê–ù–ù–´–ï (—É–∂–µ —Ä–∞—Å—Å—á–∏—Ç–∞–Ω–Ω—ã–µ):
üí∞ –û–±—â–∞—è —Å—É–º–º–∞: ${analyticsData.totalAmount}
üìä –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç—Ä–∞—Ç: ${analyticsData.totalExpenses}
üèÜ –¢–æ–ø –∫–∞—Ç–µ–≥–æ—Ä–∏—è: ${analyticsData.topCategory}
üìà –°—Ä–µ–¥–Ω–µ–µ –≤ –¥–µ–Ω—å: ${analyticsData.averagePerDay}

üìã –ü–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º:
${categoryList}

üìÖ –ü–æ –º–µ—Å—è—Ü–∞–º:
${monthlyList}

–í–ê–ñ–ù–û: 
- –ò—Å–ø–æ–ª—å–∑—É–π –¢–û–õ–¨–ö–û —ç—Ç–∏ —Ç–æ—á–Ω—ã–µ —Ü–∏—Ñ—Ä—ã, –Ω–µ –≤—ã–¥—É–º—ã–≤–∞–π –¥—Ä—É–≥–∏–µ
- –í—Å–µ —Å—É–º–º—ã —É–∂–µ –≤ –≤–∞–ª—é—Ç–µ ${analyticsData.primaryCurrency}
- –ü—Ä–æ—Ü–µ–Ω—Ç—ã —É–∂–µ —Ä–∞—Å—Å—á–∏—Ç–∞–Ω—ã –ø—Ä–∞–≤–∏–ª—å–Ω–æ
- –¢–æ–ø –∫–∞—Ç–µ–≥–æ—Ä–∏—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ: "${analyticsData.topCategory}"

–î–∞–π –∫—Ä–∞—Ç–∫–∏–π –ø–æ–ª–µ–∑–Ω—ã–π –æ—Ç–≤–µ—Ç —Å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º–∏ —Ü–∏—Ñ—Ä–∞–º–∏. –ò—Å–ø–æ–ª—å–∑—É–π —ç–º–æ–¥–∑–∏ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π.`;

      const completion = await openai.chat.completions.create({
        model: 'gpt-4',
        messages: [
          {
            role: 'system',
            content: '–¢—ã AI-–∞–Ω–∞–ª–∏—Ç–∏–∫ –ª–∏—á–Ω—ã—Ö —Ñ–∏–Ω–∞–Ω—Å–æ–≤. –ò—Å–ø–æ–ª—å–∑—É–π –¢–û–õ–¨–ö–û –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–µ —Ç–æ—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ. –ù–µ –≤—ã–¥—É–º—ã–≤–∞–π —Ü–∏—Ñ—Ä—ã.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.2, // Lower temperature for more accurate responses
        max_tokens: 500
      });

      return completion.choices[0].message.content.trim();

    } catch (error) {
      logger.error('OpenAI analytics with data failed:', error);
      throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Ä–∞—Å—Ö–æ–¥—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
    }
  }

  async analyzeExpensesWithFlexibleData(userQuestion, analyticsData, userId) {
    try {
      const categoryList = analyticsData.categoryBreakdown
        .map(cat => `${cat.category}: ${cat.formatted} (${cat.percentage}%)`).join('\\n');
      
      const monthlyList = analyticsData.monthlyBreakdown
        .map(month => `${month.month}: ${month.formatted}`).join('\\n');

      // Prepare detailed expense list for specific queries
      const expensesList = analyticsData.detailedExpenses
        .slice(0, 100) // Limit to avoid token overflow
        .map(exp => `${exp.date}: ${exp.description} - ${exp.amount} ${exp.currency} (${exp.category})`)
        .join('\\n');

      const prompt = `–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å–ø—Ä–∞—à–∏–≤–∞–µ—Ç: "${userQuestion}"

–ê–ì–†–ï–ì–ò–†–û–í–ê–ù–ù–´–ï –î–ê–ù–ù–´–ï (—É–∂–µ —Ç–æ—á–Ω–æ —Ä–∞—Å—Å—á–∏—Ç–∞–Ω–Ω—ã–µ):
üí∞ –û–±—â–∞—è —Å—É–º–º–∞: ${analyticsData.totalAmount}
üìä –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç—Ä–∞—Ç: ${analyticsData.totalExpenses}  
üèÜ –¢–æ–ø –∫–∞—Ç–µ–≥–æ—Ä–∏—è: ${analyticsData.topCategory}
üìà –°—Ä–µ–¥–Ω–µ–µ –≤ –¥–µ–Ω—å: ${analyticsData.averagePerDay}

üìã –ü–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º:
${categoryList}

üìÖ –ü–æ –º–µ—Å—è—Ü–∞–º:
${monthlyList}

–î–ï–¢–ê–õ–¨–ù–´–ï –¢–†–ê–¢–´ (–¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ –æ–ø–∏—Å–∞–Ω–∏—é, –º–µ—Å—Ç–∞–º, –¥–∞—Ç–∞–º):
${expensesList}

–ò–ù–°–¢–†–£–ö–¶–ò–ò:
1. –ï—Å–ª–∏ –≤–æ–ø—Ä–æ—Å –æ —Å—É–º–º–∞—Ö/—Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–µ - –∏—Å–ø–æ–ª—å–∑—É–π –¢–û–õ–¨–ö–û –∞–≥—Ä–µ–≥–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
2. –ï—Å–ª–∏ –Ω—É–∂–Ω–æ –Ω–∞–π—Ç–∏ —Ç—Ä–∞—Ç—ã –ø–æ –æ–ø–∏—Å–∞–Ω–∏—é/–º–µ—Å—Ç—É - –∏—â–∏ –≤ –¥–µ—Ç–∞–ª—å–Ω—ã—Ö —Ç—Ä–∞—Ç–∞—Ö  
3. –í–ê–ñ–ù–û: –ò—â–∏ –ø–æ –¢–û–ß–ù–û–ú–£ –æ–ø–∏—Å–∞–Ω–∏—é! "–≤–∫—É—Å–Ω—è—à–∫–∏" ‚â† "–µ–¥–∞", —Å–º–æ—Ç—Ä–∏ –æ–ø–∏—Å–∞–Ω–∏—è —Ç—Ä–∞—Ç!
4. –í—Å–µ —Å—É–º–º—ã —É–∂–µ –≤ –≤–∞–ª—é—Ç–µ ${analyticsData.primaryCurrency}
5. –ù–ï –≤—ã–¥—É–º—ã–≤–∞–π —Ü–∏—Ñ—Ä—ã, –∏—Å–ø–æ–ª—å–∑—É–π —Ç–æ–ª—å–∫–æ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
6. –ü—Ä–∏ –ø–æ–∏—Å–∫–µ –ø–æ –∫–ª—é—á–µ–≤–æ–º—É —Å–ª–æ–≤—É (–Ω–∞–ø—Ä–∏–º–µ—Ä "–≤–∫—É—Å–Ω—è—à–∫–∏") –∏—â–∏ –ò–ú–ï–ù–ù–û —ç—Ç–æ —Å–ª–æ–≤–æ –≤ –æ–ø–∏—Å–∞–Ω–∏—è—Ö

–î–∞–π —Ç–æ—á–Ω—ã–π –æ—Ç–≤–µ—Ç —Å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º–∏ —Ü–∏—Ñ—Ä–∞–º–∏. –ò—Å–ø–æ–ª—å–∑—É–π —ç–º–æ–¥–∑–∏ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π.`;

      const completion = await openai.chat.completions.create({
        model: 'gpt-4',
        messages: [
          {
            role: 'system',
            content: '–¢—ã AI-–∞–Ω–∞–ª–∏—Ç–∏–∫ –ª–∏—á–Ω—ã—Ö —Ñ–∏–Ω–∞–Ω—Å–æ–≤. –ò—Å–ø–æ–ª—å–∑—É–π –∞–≥—Ä–µ–≥–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏, –¥–µ—Ç–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ –æ–ø–∏—Å–∞–Ω–∏—è–º. –ù–ï –≤—ã–¥—É–º—ã–≤–∞–π —Ü–∏—Ñ—Ä—ã.'
          },
          {
            role: 'user', 
            content: prompt
          }
        ],
        temperature: 0.2,
        max_tokens: 600
      });

      return completion.choices[0].message.content.trim();

    } catch (error) {
      logger.error('OpenAI flexible analytics failed:', error);
      throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Ä–∞—Å—Ö–æ–¥—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
    }
  }

  async categorizeExpense(description, availableCategories) {
    try {
      const prompt = `
–û–ø—Ä–µ–¥–µ–ª–∏ –Ω–∞–∏–±–æ–ª–µ–µ –ø–æ–¥—Ö–æ–¥—è—â—É—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é –¥–ª—è –ø–æ–∫—É–ø–∫–∏: "${description}"

–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏:
${availableCategories.join('\n')}

–í–µ—Ä–Ω–∏ —Ç–æ–ª—å–∫–æ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –±–µ–∑ —ç–º–æ–¥–∑–∏, —Ç–æ—á–Ω–æ –∫–∞–∫ –≤ —Å–ø–∏—Å–∫–µ.
–ï—Å–ª–∏ –Ω–µ —É–≤–µ—Ä–µ–Ω, –≤—ã–±–µ—Ä–∏ "–ü—Ä–æ—á–µ–µ".
      `;

      const completion = await openai.chat.completions.create({
        model: 'gpt-3.5-turbo',
        messages: [
          {
            role: 'system',
            content: '–¢—ã –ø–æ–º–æ—â–Ω–∏–∫ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∑–∞—Ü–∏–∏ —Ä–∞—Å—Ö–æ–¥–æ–≤. –í–æ–∑–≤—Ä–∞—â–∞–π —Ç–æ–ª—å–∫–æ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.1,
        max_tokens: 50
      });

      const result = completion.choices[0].message.content.trim();
      
      // Find matching category (case-insensitive)
      const matchedCategory = availableCategories.find(cat => 
        cat.toLowerCase().includes(result.toLowerCase()) || 
        result.toLowerCase().includes(cat.toLowerCase())
      );

      return matchedCategory || '–ü—Ä–æ—á–µ–µ';
    } catch (error) {
      logger.error('Expense categorization failed:', error);
      return '–ü—Ä–æ—á–µ–µ';
    }
  }

  async generateSmartSuggestions(description, userPatterns) {
    if (!userPatterns || userPatterns.length === 0) return null;

    // Find patterns that match the description
    const matchingPatterns = userPatterns.filter(pattern =>
      description.toLowerCase().includes(pattern.keyword.toLowerCase()) ||
      pattern.keyword.toLowerCase().includes(description.toLowerCase())
    );

    if (matchingPatterns.length === 0) return null;

    // Return the pattern with highest confidence
    const bestPattern = matchingPatterns.reduce((best, current) =>
      current.confidence > best.confidence ? current : best
    );

    if (bestPattern.confidence > 0.6) {
      return {
        category: bestPattern.category,
        amount: bestPattern.avg_amount,
        currency: bestPattern.currency,
        confidence: bestPattern.confidence
      };
    }

    return null;
  }
}

module.exports = new OpenAIService();