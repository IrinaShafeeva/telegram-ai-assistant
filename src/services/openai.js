const OpenAI = require('openai');
const FormData = require('form-data');
const axios = require('axios');
const { EXPENSE_PARSING_PROMPT, ANALYTICS_PROMPT } = require('../config/constants');
const logger = require('../utils/logger');

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

class OpenAIService {
  async transcribeVoice(audioBuffer, mimeType = 'audio/ogg') {
    try {
      const formData = new FormData();
      formData.append('file', audioBuffer, {
        filename: 'voice.ogg',
        contentType: mimeType,
      });
      formData.append('model', 'whisper-1');
      formData.append('language', 'ru');

      const response = await axios.post('https://api.openai.com/v1/audio/transcriptions', formData, {
        headers: {
          'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
          ...formData.getHeaders(),
        },
      });

      return response.data.text;
    } catch (error) {
      logger.error('Voice transcription failed:', error);
      throw new Error('ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ñ€Ð°ÑÐ¿Ð¾Ð·Ð½Ð°Ñ‚ÑŒ Ð³Ð¾Ð»Ð¾ÑÐ¾Ð²Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ');
    }
  }

  async parseExpense(userInput, userPatterns = null) {
    try {
      let prompt = EXPENSE_PARSING_PROMPT.replace('{{userInput}}', userInput);
      
      // Add smart defaults context if available
      if (userPatterns && userPatterns.length > 0) {
        const patternsContext = userPatterns.map(p => 
          `"${p.keyword}" â†’ ${p.category} (${p.avg_amount} ${p.currency})`
        ).join('\n');
        
        prompt += `\n\nÐ˜ÑÑ‚Ð¾Ñ€Ð¸Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ (Ð´Ð»Ñ ÑƒÐ»ÑƒÑ‡ÑˆÐµÐ½Ð¸Ñ Ñ‚Ð¾Ñ‡Ð½Ð¾ÑÑ‚Ð¸):\n${patternsContext}`;
      }

      const completion = await openai.chat.completions.create({
        model: 'gpt-4',
        messages: [
          {
            role: 'system',
            content: 'Ð¢Ñ‹ Ð¿Ð¾Ð¼Ð¾Ñ‰Ð½Ð¸Ðº Ð¿Ð¾ Ð°Ð½Ð°Ð»Ð¸Ð·Ñƒ Ñ‚Ñ€Ð°Ñ‚. Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°Ð¹ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð²Ð°Ð»Ð¸Ð´Ð½Ñ‹Ð¹ JSON Ð±ÐµÐ· Ð´Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ñ… ÐºÐ¾Ð¼Ð¼ÐµÐ½Ñ‚Ð°Ñ€Ð¸ÐµÐ².'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.1,
        max_tokens: 200
      });

      const result = completion.choices[0].message.content.trim();
      
      // Remove markdown code blocks if present
      const cleanResult = result.replace(/```json\n?|\n?```/g, '');
      
      try {
        const parsed = JSON.parse(cleanResult);
        
        // Validate required fields
        if (!parsed.amount || isNaN(parsed.amount)) {
          throw new Error('Invalid amount');
        }
        
        // Clean and validate data
        return {
          amount: parseFloat(parsed.amount),
          currency: parsed.currency || null,
          description: parsed.description || 'Ð Ð°ÑÑ…Ð¾Ð´',
          category: parsed.category || null
        };
      } catch (parseError) {
        logger.error('Failed to parse OpenAI response:', result);
        throw new Error('ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ð¾Ð½ÑÑ‚ÑŒ ÑÑƒÐ¼Ð¼Ñƒ Ñ€Ð°ÑÑ…Ð¾Ð´Ð°. ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð½Ð°Ð¿Ð¸ÑÐ°Ñ‚ÑŒ ÑÑÐ½ÐµÐµ.');
      }
    } catch (error) {
      logger.error('Expense parsing failed:', error);
      throw error;
    }
  }

  async analyzeExpenses(userQuestion, expensesData, userId) {
    try {
      // Prepare expense data for context
      const expenseContext = expensesData.map(exp => 
        `${exp.expense_date}: ${exp.description} - ${exp.amount} ${exp.currency} (${exp.category})`
      ).join('\n');

      const prompt = ANALYTICS_PROMPT
        .replace('{{userQuestion}}', userQuestion)
        .replace('{{expenseData}}', expenseContext || 'ÐÐµÑ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¾ Ñ€Ð°ÑÑ…Ð¾Ð´Ð°Ñ…');

      const completion = await openai.chat.completions.create({
        model: 'gpt-4',
        messages: [
          {
            role: 'system',
            content: 'Ð¢Ñ‹ AI-Ð°Ð½Ð°Ð»Ð¸Ñ‚Ð¸Ðº Ð»Ð¸Ñ‡Ð½Ñ‹Ñ… Ñ„Ð¸Ð½Ð°Ð½ÑÐ¾Ð². Ð”Ð°Ð²Ð°Ð¹ ÐºÑ€Ð°Ñ‚ÐºÐ¸Ðµ, Ð¿Ð¾Ð»ÐµÐ·Ð½Ñ‹Ðµ Ð¾Ñ‚Ð²ÐµÑ‚Ñ‹ Ñ ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ñ‹Ð¼Ð¸ Ñ†Ð¸Ñ„Ñ€Ð°Ð¼Ð¸ Ð¸ Ð¸Ð½ÑÐ°Ð¹Ñ‚Ð°Ð¼Ð¸. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ ÑÐ¼Ð¾Ð´Ð·Ð¸ Ð´Ð»Ñ ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ð¹.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.3,
        max_tokens: 500
      });

      return completion.choices[0].message.content.trim();
    } catch (error) {
      logger.error('Expense analysis failed:', error);
      throw new Error('ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ñ€Ð¾Ð°Ð½Ð°Ð»Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ñ€Ð°ÑÑ…Ð¾Ð´Ñ‹. ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð¿Ð¾Ð·Ð¶Ðµ.');
    }
  }

  async analyzeExpensesWithData(userQuestion, analyticsData, userId) {
    try {
      const categoryList = analyticsData.categoryBreakdown
        .map(cat => `${cat.category}: ${cat.formatted} (${cat.percentage}%)`)
        .join('\n');
      
      const monthlyList = analyticsData.monthlyBreakdown
        .map(month => `${month.month}: ${month.formatted}`)
        .join('\n');

      const prompt = `ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ ÑÐ¿Ñ€Ð°ÑˆÐ¸Ð²Ð°ÐµÑ‚: "${userQuestion}"

Ð¢ÐžÐ§ÐÐ«Ð• Ð”ÐÐÐÐ«Ð• (ÑƒÐ¶Ðµ Ñ€Ð°ÑÑÑ‡Ð¸Ñ‚Ð°Ð½Ð½Ñ‹Ðµ):
ðŸ’° ÐžÐ±Ñ‰Ð°Ñ ÑÑƒÐ¼Ð¼Ð°: ${analyticsData.totalAmount}
ðŸ“Š ÐšÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ñ‚Ñ€Ð°Ñ‚: ${analyticsData.totalExpenses}
ðŸ† Ð¢Ð¾Ð¿ ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ñ: ${analyticsData.topCategory}
ðŸ“ˆ Ð¡Ñ€ÐµÐ´Ð½ÐµÐµ Ð² Ð´ÐµÐ½ÑŒ: ${analyticsData.averagePerDay}

ðŸ“‹ ÐŸÐ¾ ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸ÑÐ¼:
${categoryList}

ðŸ“… ÐŸÐ¾ Ð¼ÐµÑÑÑ†Ð°Ð¼:
${monthlyList}

Ð’ÐÐ–ÐÐž: 
- Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ Ð¢ÐžÐ›Ð¬ÐšÐž ÑÑ‚Ð¸ Ñ‚Ð¾Ñ‡Ð½Ñ‹Ðµ Ñ†Ð¸Ñ„Ñ€Ñ‹, Ð½Ðµ Ð²Ñ‹Ð´ÑƒÐ¼Ñ‹Ð²Ð°Ð¹ Ð´Ñ€ÑƒÐ³Ð¸Ðµ
- Ð’ÑÐµ ÑÑƒÐ¼Ð¼Ñ‹ ÑƒÐ¶Ðµ Ð² Ð²Ð°Ð»ÑŽÑ‚Ðµ ${analyticsData.primaryCurrency}
- ÐŸÑ€Ð¾Ñ†ÐµÐ½Ñ‚Ñ‹ ÑƒÐ¶Ðµ Ñ€Ð°ÑÑÑ‡Ð¸Ñ‚Ð°Ð½Ñ‹ Ð¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¾
- Ð¢Ð¾Ð¿ ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ñ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð° ÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ð¾: "${analyticsData.topCategory}"

Ð”Ð°Ð¹ ÐºÑ€Ð°Ñ‚ÐºÐ¸Ð¹ Ð¿Ð¾Ð»ÐµÐ·Ð½Ñ‹Ð¹ Ð¾Ñ‚Ð²ÐµÑ‚ Ñ ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ñ‹Ð¼Ð¸ Ñ†Ð¸Ñ„Ñ€Ð°Ð¼Ð¸. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ ÑÐ¼Ð¾Ð´Ð·Ð¸ Ð´Ð»Ñ ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ð¹.`;

      const completion = await openai.chat.completions.create({
        model: 'gpt-4',
        messages: [
          {
            role: 'system',
            content: 'Ð¢Ñ‹ AI-Ð°Ð½Ð°Ð»Ð¸Ñ‚Ð¸Ðº Ð»Ð¸Ñ‡Ð½Ñ‹Ñ… Ñ„Ð¸Ð½Ð°Ð½ÑÐ¾Ð². Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ Ð¢ÐžÐ›Ð¬ÐšÐž Ð¿Ñ€ÐµÐ´Ð¾ÑÑ‚Ð°Ð²Ð»ÐµÐ½Ð½Ñ‹Ðµ Ñ‚Ð¾Ñ‡Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ. ÐÐµ Ð²Ñ‹Ð´ÑƒÐ¼Ñ‹Ð²Ð°Ð¹ Ñ†Ð¸Ñ„Ñ€Ñ‹.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.2, // Lower temperature for more accurate responses
        max_tokens: 500
      });

      return completion.choices[0].message.content.trim();

    } catch (error) {
      logger.error('OpenAI analytics with data failed:', error);
      throw new Error('ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ñ€Ð¾Ð°Ð½Ð°Ð»Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ñ€Ð°ÑÑ…Ð¾Ð´Ñ‹. ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð¿Ð¾Ð·Ð¶Ðµ.');
    }
  }

  async analyzeExpensesWithFlexibleData(userQuestion, analyticsData, userId) {
    try {
      const categoryList = analyticsData.categoryBreakdown
        .map(cat => `${cat.category}: ${cat.formatted} (${cat.percentage}%)`).join('\\n');
      
      const monthlyList = analyticsData.monthlyBreakdown
        .map(month => `${month.month}: ${month.formatted}`).join('\\n');

      // Prepare detailed expense list for specific queries
      const expensesList = analyticsData.detailedExpenses
        .slice(0, 100) // Limit to avoid token overflow
        .map(exp => `${exp.date}: ${exp.description} - ${exp.amount} ${exp.currency} (${exp.category})`)
        .join('\\n');

      const prompt = `ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ ÑÐ¿Ñ€Ð°ÑˆÐ¸Ð²Ð°ÐµÑ‚: "${userQuestion}"

ÐÐ“Ð Ð•Ð“Ð˜Ð ÐžÐ’ÐÐÐÐ«Ð• Ð”ÐÐÐÐ«Ð• (ÑƒÐ¶Ðµ Ñ‚Ð¾Ñ‡Ð½Ð¾ Ñ€Ð°ÑÑÑ‡Ð¸Ñ‚Ð°Ð½Ð½Ñ‹Ðµ):
ðŸ’° ÐžÐ±Ñ‰Ð°Ñ ÑÑƒÐ¼Ð¼Ð°: ${analyticsData.totalAmount}
ðŸ“Š ÐšÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ñ‚Ñ€Ð°Ñ‚: ${analyticsData.totalExpenses}  
ðŸ† Ð¢Ð¾Ð¿ ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ñ: ${analyticsData.topCategory}
ðŸ“ˆ Ð¡Ñ€ÐµÐ´Ð½ÐµÐµ Ð² Ð´ÐµÐ½ÑŒ: ${analyticsData.averagePerDay}

ðŸ“‹ ÐŸÐ¾ ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸ÑÐ¼:
${categoryList}

ðŸ“… ÐŸÐ¾ Ð¼ÐµÑÑÑ†Ð°Ð¼:
${monthlyList}

Ð”Ð•Ð¢ÐÐ›Ð¬ÐÐ«Ð• Ð¢Ð ÐÐ¢Ð« (Ð´Ð»Ñ Ð¿Ð¾Ð¸ÑÐºÐ° Ð¿Ð¾ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸ÑŽ, Ð¼ÐµÑÑ‚Ð°Ð¼, Ð´Ð°Ñ‚Ð°Ð¼):
${expensesList}

Ð˜ÐÐ¡Ð¢Ð Ð£ÐšÐ¦Ð˜Ð˜:
1. Ð•ÑÐ»Ð¸ Ð²Ð¾Ð¿Ñ€Ð¾Ñ Ð¾ ÑÑƒÐ¼Ð¼Ð°Ñ…/ÑÑ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÐµ - Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ Ð¢ÐžÐ›Ð¬ÐšÐž Ð°Ð³Ñ€ÐµÐ³Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ
2. Ð•ÑÐ»Ð¸ Ð½ÑƒÐ¶Ð½Ð¾ Ð½Ð°Ð¹Ñ‚Ð¸ Ñ‚Ñ€Ð°Ñ‚Ñ‹ Ð¿Ð¾ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸ÑŽ/Ð¼ÐµÑÑ‚Ñƒ - Ð¸Ñ‰Ð¸ Ð² Ð´ÐµÑ‚Ð°Ð»ÑŒÐ½Ñ‹Ñ… Ñ‚Ñ€Ð°Ñ‚Ð°Ñ…  
3. Ð’ÐÐ–ÐÐž: Ð˜Ñ‰Ð¸ Ð¿Ð¾ Ð¢ÐžÐ§ÐÐžÐœÐ£ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸ÑŽ! "Ð²ÐºÑƒÑÐ½ÑÑˆÐºÐ¸" â‰  "ÐµÐ´Ð°", ÑÐ¼Ð¾Ñ‚Ñ€Ð¸ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ñ Ñ‚Ñ€Ð°Ñ‚!
4. Ð’ÑÐµ ÑÑƒÐ¼Ð¼Ñ‹ ÑƒÐ¶Ðµ Ð² Ð²Ð°Ð»ÑŽÑ‚Ðµ ${analyticsData.primaryCurrency}
5. ÐÐ• Ð²Ñ‹Ð´ÑƒÐ¼Ñ‹Ð²Ð°Ð¹ Ñ†Ð¸Ñ„Ñ€Ñ‹, Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¿Ñ€ÐµÐ´Ð¾ÑÑ‚Ð°Ð²Ð»ÐµÐ½Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ
6. ÐŸÑ€Ð¸ Ð¿Ð¾Ð¸ÑÐºÐµ Ð¿Ð¾ ÐºÐ»ÑŽÑ‡ÐµÐ²Ð¾Ð¼Ñƒ ÑÐ»Ð¾Ð²Ñƒ (Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€ "Ð²ÐºÑƒÑÐ½ÑÑˆÐºÐ¸") Ð¸Ñ‰Ð¸ Ð˜ÐœÐ•ÐÐÐž ÑÑ‚Ð¾ ÑÐ»Ð¾Ð²Ð¾ Ð² Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸ÑÑ…

Ð”Ð°Ð¹ Ñ‚Ð¾Ñ‡Ð½Ñ‹Ð¹ Ð¾Ñ‚Ð²ÐµÑ‚ Ñ ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ñ‹Ð¼Ð¸ Ñ†Ð¸Ñ„Ñ€Ð°Ð¼Ð¸. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ ÑÐ¼Ð¾Ð´Ð·Ð¸ Ð´Ð»Ñ ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ð¹.`;

      const completion = await openai.chat.completions.create({
        model: 'gpt-4',
        messages: [
          {
            role: 'system',
            content: 'Ð¢Ñ‹ AI-Ð°Ð½Ð°Ð»Ð¸Ñ‚Ð¸Ðº Ð»Ð¸Ñ‡Ð½Ñ‹Ñ… Ñ„Ð¸Ð½Ð°Ð½ÑÐ¾Ð². Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ Ð°Ð³Ñ€ÐµÐ³Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð´Ð»Ñ ÑÑ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÐ¸, Ð´ÐµÑ‚Ð°Ð»ÑŒÐ½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð´Ð»Ñ Ð¿Ð¾Ð¸ÑÐºÐ° Ð¿Ð¾ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸ÑÐ¼. ÐÐ• Ð²Ñ‹Ð´ÑƒÐ¼Ñ‹Ð²Ð°Ð¹ Ñ†Ð¸Ñ„Ñ€Ñ‹.'
          },
          {
            role: 'user', 
            content: prompt
          }
        ],
        temperature: 0.2,
        max_tokens: 600
      });

      return completion.choices[0].message.content.trim();

    } catch (error) {
      logger.error('OpenAI flexible analytics failed:', error);
      throw new Error('ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ñ€Ð¾Ð°Ð½Ð°Ð»Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ñ€Ð°ÑÑ…Ð¾Ð´Ñ‹. ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð¿Ð¾Ð·Ð¶Ðµ.');
    }
  }

  async categorizeExpense(description, availableCategories) {
    try {
      const prompt = `
ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»Ð¸ Ð½Ð°Ð¸Ð±Ð¾Ð»ÐµÐµ Ð¿Ð¾Ð´Ñ…Ð¾Ð´ÑÑ‰ÑƒÑŽ ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸ÑŽ Ð´Ð»Ñ Ð¿Ð¾ÐºÑƒÐ¿ÐºÐ¸: "${description}"

Ð”Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹Ðµ ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ð¸:
${availableCategories.join('\n')}

Ð’ÐµÑ€Ð½Ð¸ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ð¸ Ð±ÐµÐ· ÑÐ¼Ð¾Ð´Ð·Ð¸, Ñ‚Ð¾Ñ‡Ð½Ð¾ ÐºÐ°Ðº Ð² ÑÐ¿Ð¸ÑÐºÐµ.
Ð•ÑÐ»Ð¸ Ð½Ðµ ÑƒÐ²ÐµÑ€ÐµÐ½, Ð²Ñ‹Ð±ÐµÑ€Ð¸ "ÐŸÑ€Ð¾Ñ‡ÐµÐµ".
      `;

      const completion = await openai.chat.completions.create({
        model: 'gpt-3.5-turbo',
        messages: [
          {
            role: 'system',
            content: 'Ð¢Ñ‹ Ð¿Ð¾Ð¼Ð¾Ñ‰Ð½Ð¸Ðº Ð¿Ð¾ ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ð·Ð°Ñ†Ð¸Ð¸ Ñ€Ð°ÑÑ…Ð¾Ð´Ð¾Ð². Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°Ð¹ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ð¸.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.1,
        max_tokens: 50
      });

      const result = completion.choices[0].message.content.trim();
      
      // Find matching category (case-insensitive)
      const matchedCategory = availableCategories.find(cat => 
        cat.toLowerCase().includes(result.toLowerCase()) || 
        result.toLowerCase().includes(cat.toLowerCase())
      );

      return matchedCategory || 'ÐŸÑ€Ð¾Ñ‡ÐµÐµ';
    } catch (error) {
      logger.error('Expense categorization failed:', error);
      return 'ÐŸÑ€Ð¾Ñ‡ÐµÐµ';
    }
  }

  async generateSmartSuggestions(description, userPatterns) {
    if (!userPatterns || userPatterns.length === 0) return null;

    // Find patterns that match the description
    const matchingPatterns = userPatterns.filter(pattern =>
      description.toLowerCase().includes(pattern.keyword.toLowerCase()) ||
      pattern.keyword.toLowerCase().includes(description.toLowerCase())
    );

    if (matchingPatterns.length === 0) return null;

    // Return the pattern with highest confidence
    const bestPattern = matchingPatterns.reduce((best, current) =>
      current.confidence > best.confidence ? current : best
    );

    if (bestPattern.confidence > 0.6) {
      return {
        category: bestPattern.category,
        amount: bestPattern.avg_amount,
        currency: bestPattern.currency,
        confidence: bestPattern.confidence
      };
    }

    return null;
  }
}

module.exports = new OpenAIService();